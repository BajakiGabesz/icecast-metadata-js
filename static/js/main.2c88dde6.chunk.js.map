{"version":3,"sources":["About/About.module.css","App.module.css","icecast/metadata-js/IcecastMetadataQueue.js","icecast/metadata-js/MetadataBuffer.js","icecast/metadata-js/IcecastMetadataReader.js","icecast/metadata-js/IcecastReadableStream.js","icecast/MetadataPlayer.js","Player/play.svg","Player/pause.svg","Player/Player.jsx","StationSelector/StationSelector.jsx","About/About.jsx","App.js","serviceWorker.js","index.js","Player/Player.module.css","StationSelector/StationSelector.module.css"],"names":["module","exports","IcecastMetadataQueue","icyBr","onMetadataUpdate","this","_icyBr","_onMetadataUpdate","_metadataQueue","bufferOffset","metadata","_enqueueMetadata","bytesRead","forEach","i","clearTimeout","_timeoutId","time","push","setTimeout","_dequeueMetadata","shift","map","MetadataBuffer","expectedLength","_buffer","Uint8Array","_length","data","set","length","Stats","_totalBytesRead","_streamBytesRead","_metadataLengthBytesRead","_metadataBytesRead","_currentBytesRemaining","_currentStreamBytesRemaining","_currentMetadataBytesRemaining","totalBytesRead","streamBytesRead","metadataLengthBytesRead","metadataBytesRead","currentBytesRemaining","currentStreamBytesRemaining","currentMetadataBytesRemaining","bytes","noOp","IcecastMetadataReader","icyMetaInt","onStream","onMetadata","_icyMetaInt","_remainingData","_currentPosition","_stats","_decoder","TextDecoder","_onStream","_onMetadata","_onStreamPromise","Promise","resolve","_onMetadataPromise","_generator","next","metadataBytes","parseMetadataString","decode","chunk","value","_getStream","_getMetadataLength","_getMetadata","_getNextValue","stream","addStreamBytes","streamPayload","stats","addMetadataLengthBytes","addMetadataBytes","_storeMetadata","metadataPayload","parseMetadata","currentMetadata","metadataBuffer","pop","subarray","metadataString","matchAll","match","IcecastReadableStream","response","readerIterator","asyncIterator","body","start","controller","icecast","parseInt","headers","get","enqueue","close","readableStream","reader","getReader","Symbol","read","ReadableStream","MetadataPlayer","_icecastMetadataQueue","meta","_audioElement","Audio","_playing","mimeType","_mediaSource","MediaSource","src","URL","createObjectURL","addEventListener","_sourceBuffer","addSourceBuffer","once","_playPromise","then","removeAttribute","load","catch","appendBuffer","endpoint","fetch","method","mode","headResponse","signal","_controller","stop","AbortController","streamPromise","fetchStream","race","fetchMimeType","res","a","isTypeSupported","_createMediaSource","Error","play","_appendSourceBuffer","addMetadata","timestampOffset","currentTime","e","name","message","_destroyMediaSource","abort","purgeMetadataQueue","_extends","Object","assign","target","arguments","source","key","prototype","hasOwnProperty","call","apply","_objectWithoutProperties","excluded","sourceKeys","keys","indexOf","_objectWithoutPropertiesLoose","getOwnPropertySymbols","sourceSymbolKeys","propertyIsEnumerable","createElement","fill","d","_ref","svgRef","title","props","viewBox","ref","ForwardRef","forwardRef","station","useState","console","log","metadataPlayer","useCallback","metaInt","useEffect","playing","useMetadataPlayer","isPlaying","toggle","className","styles","player","disabled","Boolean","button","onClick","StreamTitle","link","visitStation","href","rel","Station","id","changeStation","type","stationRadio","onChange","stationLabel","htmlFor","stationName","stationDescription","description","stations","idx","about","subLink","disclaimer","App","setStation","header","About","StationSelector","footer","Player","window","location","hostname","ReactDOM","render","StrictMode","document","getElementById","navigator","serviceWorker","ready","registration","unregister","error"],"mappings":"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","file":"static/js/main.2c88dde6.chunk.js","sourcesContent":["// extracted by mini-css-extract-plugin\nmodule.exports = {\"about\":\"About_about__2v-0B\",\"link\":\"About_link__1z8T1\",\"subLink\":\"About_subLink__n5KCY\",\"description\":\"About_description__3WN3o\",\"disclaimer\":\"About_disclaimer__2gOk6\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"header\":\"App_header__3ZZ1n\",\"footer\":\"App_footer__29Fsv\"};","/* Copyright 2020 Ethan Halsall\n\n    This program is free software: you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with this program.  If not, see <https://www.gnu.org/licenses/>\n*/\n\nexport default class IcecastMetadataQueue {\n  /**\n   * @description Schedules updates up to the millisecond for Icecast Metadata from the response body of an Icecast stream mountpoint\n   * @description The accuracy of metadata updates is a direct relationship of the icyMetaInt\n   * @param {Object} IcecastMetadataQueue constructor parameter\n   * @param {number} [IcecastMetadataQueue.icyBr] Bitrate of audio stream used to increase accuracy when to updating metadata\n   * @param {onMetadataUpdate} [IcecastMetadataQueue.onMetadataUpdate] Callback executed when metadata is scheduled to update\n   *\n   * @callback onMetadataUpdate\n   * @param {Object} metadata Object containing all metadata received.\n   * @param {string} [metadata.StreamTitle] Title of the metadata update.\n   * @param {string} [metadata.StreamUrl] Url (usually album art) of the metadata update.\n   * @param {number} time Time in seconds the metadata should be displayed / recorded\n   *\n   */\n\n  constructor({ icyBr, onMetadataUpdate = () => {} }) {\n    this._icyBr = icyBr;\n    this._onMetadataUpdate = onMetadataUpdate;\n    this._metadataQueue = [];\n  }\n\n  /**\n   * @description Returns the metadata queued for updates\n   * @type {{metadata: string, time: number}[]} Queued metadata\n   */\n  get metadataQueue() {\n    return this._metadataQueue.map(({ metadata, time }) => ({\n      metadata,\n      time,\n    }));\n  }\n\n  /**\n   *\n   * @param {object} metadata Metadata object returned from IcecastMetadataReader\n   * @param {number} bufferOffset Total buffered audio in seconds\n   */\n  addMetadata({ metadata }, bufferOffset) {\n    /**\n     * Metadata time is derived from the total number of stream bytes read\n     * since the latest buffer input. The buffer offset should be the total\n     * seconds of audio in the player buffer when the metadata was read.\n     */\n\n    this._enqueueMetadata(metadata, bufferOffset);\n  }\n\n  /**\n   * @description Calculates audio stream length based on bitrate\n   * @param {number} bytesRead Number of bytes\n   * @type {number} Seconds\n   */\n  getTimeByBytes(bytesRead) {\n    return this._icyBr ? bytesRead / (this._icyBr * 125) : 0;\n  }\n\n  /**\n   * @description Clears all metadata updates and empties the queue\n   */\n  purgeMetadataQueue() {\n    this._metadataQueue.forEach((i) => clearTimeout(i._timeoutId));\n    this._metadataQueue = [];\n  }\n\n  _enqueueMetadata(metadata, time) {\n    this._metadataQueue.push({\n      _timeoutId: setTimeout(() => {\n        this._dequeueMetadata();\n      }, time * 1000), // trigger timeout relative to play position\n      metadata,\n    });\n  }\n\n  _dequeueMetadata() {\n    const { metadata } = this._metadataQueue.shift();\n    this._onMetadataUpdate(metadata);\n  }\n}\n","/* Copyright 2020 Ethan Halsall\n\n    This program is free software: you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with this program.  If not, see <https://www.gnu.org/licenses/>\n*/\n\n// Use fast buffer allocation if this is a NodeJS runtime or Uint8Array if a browser runtime\nconst bufferFunction = (length) => new Uint8Array(length);\n\n/**\n * @description Stores a collection of buffers as an array.\n */\nexport default class MetadataBuffer {\n  constructor(expectedLength) {\n    this._buffer = bufferFunction(expectedLength);\n    this._length = 0;\n  }\n\n  get length() {\n    return this._length;\n  }\n\n  /**\n   * @type {Uint8Array} Returns all stored data\n   */\n  pop() {\n    return this._buffer;\n  }\n\n  push(data) {\n    this._buffer.set(data, this._length);\n    this._length += data.length;\n  }\n}\n","/* Copyright 2020 Ethan Halsall\n\n    This program is free software: you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with this program.  If not, see <https://www.gnu.org/licenses/>\n*/\n\nimport MetadataBuffer from \"./MetadataBuffer\";\n\nclass Stats {\n  constructor() {\n    this._totalBytesRead = 0;\n    this._streamBytesRead = 0;\n    this._metadataLengthBytesRead = 0;\n    this._metadataBytesRead = 0;\n\n    this._currentBytesRemaining = 0;\n    this._currentStreamBytesRemaining = 0;\n    this._currentMetadataBytesRemaining = 0;\n  }\n\n  get stats() {\n    return {\n      totalBytesRead: this._totalBytesRead,\n      streamBytesRead: this._streamBytesRead,\n      metadataLengthBytesRead: this._metadataLengthBytesRead,\n      metadataBytesRead: this._metadataBytesRead,\n      currentBytesRemaining: this._currentBytesRemaining,\n      currentStreamBytesRemaining: this._currentStreamBytesRemaining,\n      currentMetadataBytesRemaining: this._currentMetadataBytesRemaining,\n    };\n  }\n\n  set addStreamBytes(bytes) {\n    this._streamBytesRead += bytes;\n    this._totalBytesRead += bytes;\n    this._currentStreamBytesRemaining -= bytes;\n    this._currentBytesRemaining -= bytes;\n  }\n\n  set addMetadataLengthBytes(bytes) {\n    this._metadataLengthBytesRead += bytes;\n    this._totalBytesRead += bytes;\n    this._currentBytesRemaining -= bytes;\n  }\n\n  set addMetadataBytes(bytes) {\n    this._metadataBytesRead += bytes;\n    this._totalBytesRead += bytes;\n    this._currentMetadataBytesRemaining -= bytes;\n    this._currentBytesRemaining -= bytes;\n  }\n\n  set currentBytesRemaining(bytes) {\n    this._currentBytesRemaining = bytes;\n  }\n\n  set currentStreamBytesRemaining(bytes) {\n    this._currentStreamBytesRemaining = bytes;\n  }\n\n  set currentMetadataBytesRemaining(bytes) {\n    this._currentMetadataBytesRemaining = bytes;\n  }\n}\n\nconst noOp = () => {};\n\n/**\n * @description Splits Icecast raw response into stream bytes and metadata key / value pairs.\n * @param {number} icyMetaInt Interval in bytes of metadata updates returned by the Icecast server\n *\n * @callback onMetadata\n * @param {object} value Object containing Metadata and Statistics\n * @param {object} metadata Object containing the metadata received.\n * @param {string} [metadata.StreamTitle] Title of the metadata update.\n * @param {string} [metadata.StreamUrl] Url (usually album art) of the metadata update.\n * @param {object} stats Object containing statistics on how many bytes were read and the current read position.\n *\n * @callback onStream\n * @param {object} value Object containing Stream data and Statistics\n * @param {Uint8Array} stream Object containing the stream buffer.\n * @param {object} stats Object containing statistics on how many bytes were read and the current read position.\n */\nexport default class IcecastMetadataReader {\n  constructor({ icyMetaInt, onStream = noOp, onMetadata = noOp }) {\n    this._icyMetaInt = icyMetaInt;\n    this._remainingData = 0;\n    this._currentPosition = 0;\n    this._buffer = null;\n    this._stats = new Stats();\n    this._decoder = new TextDecoder(\"utf-8\");\n\n    this._onStream = onStream;\n    this._onMetadata = onMetadata;\n    this._onStreamPromise = Promise.resolve();\n    this._onMetadataPromise = Promise.resolve();\n\n    this._generator = this._generator();\n    this._generator.next();\n  }\n\n  /**\n   * @description Parses an Icecast metadata string into key value pairs.\n   * @param {string} metadataString Icecast formatted metadata string. (i.e. \"StreamTitle='A Title';\")\n   * @returns {object} Parsed metadata key value pairs. (i.e. {StreamTitle: \"A Title\"})\n   */\n  static parseMetadataString(metadataString) {\n    /**\n     * Metadata is a string of key='value' pairs delimited by a semicolon.\n     * The string is a fixed length and any unused bytes at the end are 0x00.\n     * i.e. \"StreamTitle='The Stream Title';StreamUrl='https://example.com';\\0\\0\\0\\0\\0\\0\"\n     */\n\n    const metadata = {};\n    // [{key: \"StreamTitle\", val: \"The Stream Title\"}, {key: \"StreamUrl\", val: \"https://example.com\"}]\n    for (let match of metadataString.matchAll(\n      /(?<key>[^\\0]+?)='(?<val>[^\\0]*?)(;$|';|'$|$)/g\n    )) {\n      metadata[match[\"groups\"][\"key\"]] = match[\"groups\"][\"val\"];\n    }\n    // {StreamTitle: \"The Stream Title\", StreamUrl: \"https://example.com\"}\n    return metadata;\n  }\n\n  /**\n   * @description Parses Icecast metadata bytes into key value pairs.\n   * @param {Uint8Array} metadataBytes Bytes containing Icecast metadata.\n   * @returns {object} Parsed metadata key value pairs. (i.e. {StreamTitle: \"A Title\"})\n   */\n  parseMetadata(metadataBytes) {\n    return IcecastMetadataReader.parseMetadataString(\n      this._decoder.decode(metadataBytes)\n    );\n  }\n\n  /**\n   * @description Returns an iterator that iterates over the passed in data.\n   * @param {Uint8Array} chunk Next chunk of data to read\n   * @returns {IterableIterator} Iterator that operates over a raw icecast response.\n   * @yields {object} Object containing stream or metadata.\n   */\n  *iterator(chunk) {\n    for (\n      let i = this._generator.next(chunk);\n      i.value;\n      i = this._generator.next()\n    ) {\n      yield i.value;\n    }\n  }\n\n  /**\n   * @description Returns an async iterator that iterates over the passed in data and awaits the onStream and onMetadata callbacks.\n   * @param {Uint8Array} chunk Next chunk of data to read\n   * @returns {IterableIterator} Iterator that operates over a raw icecast response.\n   * @yields {object} Object containing stream or metadata.\n   */\n  async *asyncIterator(chunk) {\n    for (\n      let i = this._generator.next(chunk);\n      i.value;\n      i = this._generator.next()\n    ) {\n      await this._onStreamPromise;\n      await this._onMetadataPromise;\n      yield i.value;\n    }\n  }\n\n  *_generator() {\n    do {\n      yield* this._getStream();\n      yield* this._getMetadataLength();\n      this._remainingData && (yield* this._getMetadata());\n    } while (true);\n  }\n\n  *_getStream() {\n    this._remainingData = this._icyMetaInt;\n    this._stats.currentStreamBytesRemaining = this._icyMetaInt;\n\n    do {\n      const stream = yield* this._getNextValue();\n      this._stats.addStreamBytes = stream.length;\n\n      const streamPayload = { stream, stats: this._stats.stats };\n      /**\n       * Stream callback.\n       *\n       * @callback onStream\n       * @type {object}\n       * @property {Uint8Array} stream Stream bytes.\n       * @property {object} stats Statistics on bytes read.\n       */\n      this._onStreamPromise = this._onStream(streamPayload);\n\n      yield streamPayload;\n    } while (this._remainingData);\n  }\n\n  *_getMetadataLength() {\n    this._remainingData = 1;\n\n    do {\n      this._remainingData = (yield* this._getNextValue())[0] * 16;\n    } while (this._remainingData === 1);\n\n    this._stats.addMetadataLengthBytes = 1;\n  }\n\n  *_getMetadata() {\n    this._stats.currentMetadataBytesRemaining = this._remainingData;\n\n    let metadata = yield* this._getNextValue();\n    this._stats.addMetadataBytes = metadata.length;\n\n    if (this._remainingData) metadata = yield* this._storeMetadata(metadata);\n\n    const metadataPayload = {\n      metadata: this.parseMetadata(metadata),\n      stats: this._stats.stats,\n    };\n    /**\n     * Metadata callback.\n     *\n     * @callback onMetadata\n     * @type {object}\n     * @property {object} metadata Metadata key value pairs..\n     * @param {property} [metadata.StreamTitle] Title of the metadata update.\n     * @param {property} [metadata.StreamUrl] Url (usually album art) of the metadata update.\n     * @property {object} stats Statistics on bytes read.\n     */\n    this._onMetadataPromise = this._onMetadata(metadataPayload);\n\n    yield metadataPayload;\n  }\n\n  *_storeMetadata(currentMetadata) {\n    // Store any partial metadata updates until a full metadata chunk can be parsed.\n    const metadataBuffer = new MetadataBuffer(\n      this._remainingData + currentMetadata.length\n    );\n    metadataBuffer.push(currentMetadata);\n\n    do {\n      const metadata = yield* this._getNextValue();\n      metadataBuffer.push(metadata);\n\n      this._stats.addMetadataBytes = metadata.length;\n    } while (this._remainingData);\n\n    return metadataBuffer.pop();\n  }\n\n  *_getNextValue() {\n    while (!this._buffer || this._currentPosition === this._buffer.length) {\n      this._buffer = yield; // if out of data, accept new data in the .next() call\n      this._currentPosition = 0;\n      this._stats.currentBytesRemaining = this._buffer.length;\n    }\n    const value = this._buffer.subarray(\n      this._currentPosition,\n      this._remainingData + this._currentPosition\n    );\n\n    this._remainingData -= value.length;\n    this._currentPosition += value.length;\n\n    return value;\n  }\n}\n","/* Copyright 2020 Ethan Halsall\n\n    This program is free software: you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with this program.  If not, see <https://www.gnu.org/licenses/>\n*/\n\nimport IcecastMetadataReader from \"./IcecastMetadataReader\";\n\nconst noOp = () => {};\n\n/**\n * @description Browser ReadableStream wrapper for IcecastMetadataReader\n * @extends ReadableStream\n */\nexport default class IcecastReadableStream extends ReadableStream {\n  /**\n   *\n   * @param {ReadableStream} response ReadableStream for raw Icecast response data\n   * @param {object} options Configuration options for IcecastMetadataReader\n   * @see IcecastMetadataReader for information on the options parameter\n   */\n  constructor(response, { icyMetaInt, onStream = noOp, onMetadata }) {\n    const readerIterator = IcecastReadableStream.asyncIterator(response.body);\n\n    super({\n      async start(controller) {\n        const icecast = new IcecastMetadataReader({\n          icyMetaInt:\n            parseInt(response.headers.get(\"Icy-MetaInt\")) || icyMetaInt,\n          onMetadata,\n          onStream: (value) => {\n            controller.enqueue(value.stream);\n            return onStream(value);\n          },\n        });\n\n        for await (const chunk of readerIterator) {\n          for await (let i of icecast.asyncIterator(chunk)) {\n          }\n        }\n\n        controller.close();\n      },\n    });\n  }\n\n  /**\n   * @description Creates an async iterator from this ReadableStream.\n   * @returns {Symbol.asyncIterator} Async Iterator for this ReadableStream.\n   */\n  get asyncIterator() {\n    return IcecastReadableStream.asyncIterator(this);\n  }\n\n  /**\n   * @description Wraps a ReadableStream as an Async Iterator.\n   * @param {ReadableStream} readableStream ReadableStream to convert to AsyncIterator\n   * @returns {Symbol.asyncIterator} Async Iterator that wraps the ReadableStream\n   */\n  static asyncIterator(readableStream) {\n    const reader = readableStream.getReader();\n    return {\n      [Symbol.asyncIterator]: () => ({\n        next: () => reader.read(),\n      }),\n    };\n  }\n}\n","import IcecastMetadataQueue from \"./metadata-js/IcecastMetadataQueue\";\nimport IcecastReadableStream from \"./metadata-js/IcecastReadableStream\";\n\nexport default class MetadataPlayer {\n  constructor({ onMetadataUpdate }) {\n    this._icecastMetadataQueue = new IcecastMetadataQueue({\n      onMetadataUpdate: (meta) => onMetadataUpdate(meta),\n    });\n    this._audioElement = new Audio();\n    this._onMetadataUpdate = onMetadataUpdate;\n\n    this._playing = false;\n  }\n\n  get playing() {\n    return this._playing;\n  }\n\n  async _createMediaSource(mimeType) {\n    this._mediaSource = new MediaSource();\n    this._audioElement.src = URL.createObjectURL(this._mediaSource);\n\n    return new Promise((resolve) => {\n      this._mediaSource.addEventListener(\n        \"sourceopen\",\n        () => {\n          this._sourceBuffer = this._mediaSource.addSourceBuffer(mimeType);\n          resolve();\n        },\n        { once: true }\n      );\n    });\n  }\n\n  _destroyMediaSource() {\n    this._mediaSource = null;\n    this._playPromise &&\n      this._playPromise\n        .then(() => this._audioElement.removeAttribute(\"src\"))\n        .then(() => this._audioElement.load())\n        .catch(() => {});\n  }\n\n  async _appendSourceBuffer(chunk) {\n    this._sourceBuffer.appendBuffer(chunk);\n\n    return new Promise((resolve) => {\n      this._sourceBuffer.addEventListener(\"updateend\", resolve, { once: true });\n    });\n  }\n\n  async fetchMimeType(endpoint) {\n    const headResponse = await fetch(endpoint, {\n      method: \"HEAD\",\n      mode: \"cors\",\n    }).catch(() => {});\n\n    return headResponse ? headResponse : new Promise(() => {});\n  }\n\n  async fetchStream(endpoint) {\n    return fetch(endpoint, {\n      method: \"GET\",\n      headers: {\n        \"Icy-MetaData\": \"1\",\n      },\n      signal: this._controller.signal,\n    });\n  }\n\n  play(endpoint, icyMetaInt) {\n    if (this._playing) {\n      this.stop();\n    }\n\n    this._playing = true;\n    this._controller = new AbortController();\n\n    const streamPromise = this.fetchStream(endpoint);\n\n    Promise.race([this.fetchMimeType(endpoint), streamPromise])\n      .then(async (res) => {\n        const mimeType = res.headers.get(\"content-type\");\n\n        if (MediaSource.isTypeSupported(mimeType)) {\n          await this._createMediaSource(mimeType);\n          return streamPromise;\n        } else {\n          throw new Error(\n            `Your browser does not support MediaSource ${mimeType}. Try using Google Chrome.`\n          );\n        }\n      })\n      .then(async (res) => {\n        this._playPromise = this._audioElement.play();\n\n        const icecast = new IcecastReadableStream(res, {\n          icyMetaInt,\n          onStream: ({ stream }) => this._appendSourceBuffer(stream),\n          onMetadata: (value) => {\n            this._icecastMetadataQueue.addMetadata(\n              value,\n              this._sourceBuffer.timestampOffset -\n                this._audioElement.currentTime\n            );\n          },\n        });\n\n        for await (const stream of icecast.asyncIterator) {\n        }\n      })\n      .catch((e) => {\n        if (e.name !== \"AbortError\") {\n          this._onMetadataUpdate(`Error Connecting: ${e.message}`);\n        }\n        this._destroyMediaSource();\n      });\n  }\n\n  stop() {\n    this._playing = false;\n    this._controller.abort();\n    this._icecastMetadataQueue.purgeMetadataQueue();\n  }\n}\n","function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\nimport React from \"react\";\n\nvar _ref2 = /*#__PURE__*/React.createElement(\"path\", {\n  fill: \"#808080\",\n  d: \"M424.4 214.7L72.4 6.6C43.8-10.3 0 6.1 0 47.9V464c0 37.5 40.7 60.1 72.4 41.3l352-208c31.4-18.5 31.5-64.1 0-82.6z\"\n});\n\nvar SvgPlay = function SvgPlay(_ref) {\n  var svgRef = _ref.svgRef,\n      title = _ref.title,\n      props = _objectWithoutProperties(_ref, [\"svgRef\", \"title\"]);\n\n  return /*#__PURE__*/React.createElement(\"svg\", _extends({\n    viewBox: \"0 0 448 512\",\n    ref: svgRef\n  }, props), title ? /*#__PURE__*/React.createElement(\"title\", null, title) : null, _ref2);\n};\n\nvar ForwardRef = /*#__PURE__*/React.forwardRef(function (props, ref) {\n  return /*#__PURE__*/React.createElement(SvgPlay, _extends({\n    svgRef: ref\n  }, props));\n});\nexport default __webpack_public_path__ + \"static/media/play.0187bd2f.svg\";\nexport { ForwardRef as ReactComponent };","function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\nimport React from \"react\";\n\nvar _ref2 = /*#__PURE__*/React.createElement(\"path\", {\n  fill: \"#808080\",\n  d: \"M144 479H48c-26.5 0-48-21.5-48-48V79c0-26.5 21.5-48 48-48h96c26.5 0 48 21.5 48 48v352c0 26.5-21.5 48-48 48zm304-48V79c0-26.5-21.5-48-48-48h-96c-26.5 0-48 21.5-48 48v352c0 26.5 21.5 48 48 48h96c26.5 0 48-21.5 48-48z\"\n});\n\nvar SvgPause = function SvgPause(_ref) {\n  var svgRef = _ref.svgRef,\n      title = _ref.title,\n      props = _objectWithoutProperties(_ref, [\"svgRef\", \"title\"]);\n\n  return /*#__PURE__*/React.createElement(\"svg\", _extends({\n    viewBox: \"0 0 448 512\",\n    ref: svgRef\n  }, props), title ? /*#__PURE__*/React.createElement(\"title\", null, title) : null, _ref2);\n};\n\nvar ForwardRef = /*#__PURE__*/React.forwardRef(function (props, ref) {\n  return /*#__PURE__*/React.createElement(SvgPause, _extends({\n    svgRef: ref\n  }, props));\n});\nexport default __webpack_public_path__ + \"static/media/pause.b0b65543.svg\";\nexport { ForwardRef as ReactComponent };","import React, { useEffect, useState } from \"react\";\nimport MetadataPlayer from \"../icecast/MetadataPlayer\";\nimport { ReactComponent as Play } from \"./play.svg\";\nimport { ReactComponent as Pause } from \"./pause.svg\";\nimport styles from \"./Player.module.css\";\nimport { useCallback } from \"react\";\n\nconst SELECT_STATION = \"Select a station\";\nconst SELECT_OR_PLAY = \"Select a station or press play\";\nconst LOADING = \"Loading...\";\nconst VISIT_STATION = \"Visit this station at \";\n\nconst useMetadataPlayer = (station, onMetadataUpdate) => {\n  const [metadataPlayer] = useState(\n    new MetadataPlayer({\n      onMetadataUpdate: (meta) => {\n        console.log(meta);\n        onMetadataUpdate(meta);\n      },\n    })\n  );\n\n  const play = useCallback(() => {\n    onMetadataUpdate(LOADING);\n    metadataPlayer.play(station.endpoint, station.metaInt);\n  }, [onMetadataUpdate, metadataPlayer, station]);\n\n  const stop = useCallback(() => {\n    onMetadataUpdate(SELECT_OR_PLAY);\n    metadataPlayer.stop();\n  }, [onMetadataUpdate, metadataPlayer]);\n\n  useEffect(() => {\n    station && play();\n  }, [station, play]);\n\n  const toggle = () => (metadataPlayer.playing ? stop() : play());\n\n  return [metadataPlayer.playing, toggle];\n};\n\nexport default ({ station }) => {\n  const [metadata, setMetadata] = useState(SELECT_STATION);\n  const [isPlaying, toggle] = useMetadataPlayer(station, setMetadata);\n\n  return (\n    <div className={styles.player}>\n      <button\n        disabled={!Boolean(station)}\n        className={styles.button}\n        onClick={toggle}\n      >\n        {isPlaying ? <Pause /> : <Play />}\n      </button>\n      <div>\n        <p className={styles.metadata}>\n          {typeof metadata === \"object\" ? metadata.StreamTitle : metadata}\n        </p>\n        {station?.link && (\n          <div className={styles.visitStation}>\n            {VISIT_STATION}\n            <a\n              className={styles.link}\n              href={station.link}\n              target=\"_blank\"\n              rel=\"noopener noreferrer\"\n            >\n              {station.name}\n            </a>\n          </div>\n        )}\n      </div>\n    </div>\n  );\n};\n","import React from \"react\";\nimport styles from \"./StationSelector.module.css\";\n\nconst Station = ({ id, station, changeStation }) => (\n  <div className={styles.station}>\n    <input\n      type=\"radio\"\n      className={styles.stationRadio}\n      id={id}\n      name=\"stations\"\n      onChange={() => changeStation(station)}\n    ></input>\n    <label className={styles.stationLabel} htmlFor={id}>\n      <div className={styles.stationName}>{station.name}</div>\n      <div className={styles.stationDescription}>{station.description}</div>\n    </label>\n  </div>\n);\n\nexport default (props) =>\n  props.stations.map((station, idx) => (\n    <Station\n      key={idx}\n      station={station}\n      id={idx}\n      changeStation={props.changeStation}\n    />\n  ));\n","import React from \"react\";\nimport styles from \"./About.module.css\";\n\nexport default () => (\n  <div className={styles.about}>\n    <a\n      className={styles.link}\n      href=\"https://github.com/eshaz/icecast-metadata-js\"\n    >\n      <div>icecast-metadata-js</div>\n      <div className={styles.subLink}>\n        https://github.com/eshaz/icecast-metadata-js\n      </div>\n    </a>\n    <div className={styles.description}>\n      Javascript library that reads, parses, and queues realtime metadata from\n      an Icecast stream.\n    </div>\n    <div className={styles.disclaimer}>\n      Stations are presented here for demonstration purposes only.\n    </div>\n  </div>\n);\n","import React, { useState } from \"react\";\nimport Player from \"./Player/Player\";\nimport StationSelector from \"./StationSelector/StationSelector\";\nimport stations from \"./stations.json\";\nimport styles from \"./App.module.css\";\nimport About from \"./About/About\";\n\nfunction App() {\n  const [station, setStation] = useState();\n\n  return (\n    <>\n      <header className={styles.header}>\n        <About />\n      </header>\n      <StationSelector stations={stations} changeStation={setStation} />\n      <footer className={styles.footer}>\n        <Player station={station}></Player>\n      </footer>\n    </>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === \"localhost\" ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === \"[::1]\" ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === \"production\" && \"serviceWorker\" in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener(\"load\", () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            \"This web app is being served cache-first by a service \" +\n              \"worker. To learn more, visit https://bit.ly/CRA-PWA\"\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then((registration) => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === \"installed\") {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                \"New content is available and will be used when all \" +\n                  \"tabs for this page are closed. See https://bit.ly/CRA-PWA.\"\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log(\"Content is cached for offline use.\");\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch((error) => {\n      console.error(\"Error during service worker registration:\", error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { \"Service-Worker\": \"script\" },\n  })\n    .then((response) => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get(\"content-type\");\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf(\"javascript\") === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then((registration) => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        \"No internet connection found. App is running in offline mode.\"\n      );\n    });\n}\n\nexport function unregister() {\n  if (\"serviceWorker\" in navigator) {\n    navigator.serviceWorker.ready\n      .then((registration) => {\n        registration.unregister();\n      })\n      .catch((error) => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport \"./index.css\";\nimport App from \"./App\";\nimport * as serviceWorker from \"./serviceWorker\";\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById(\"root\")\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n","// extracted by mini-css-extract-plugin\nmodule.exports = {\"player\":\"Player_player__1vYfQ\",\"metadata\":\"Player_metadata__3j7ae\",\"button\":\"Player_button__297uW\",\"link\":\"Player_link__2k87w\",\"visitStation\":\"Player_visitStation__2xKeH\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"station\":\"StationSelector_station__3a44c\",\"stationRadio\":\"StationSelector_stationRadio__1FTGQ\",\"stationLabel\":\"StationSelector_stationLabel__1DbUR\",\"stationName\":\"StationSelector_stationName__1hB_K\",\"stationDescription\":\"StationSelector_stationDescription__36TBn\"};"],"sourceRoot":""}
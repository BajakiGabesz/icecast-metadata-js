{"version":3,"sources":["../../icecast-metadata-js/src/IcecastMetadataReader.js","../../icecast-metadata-js/src/MetadataParser/MetadataParser.js","App.module.css","../../icecast-metadata-js/src/IcecastMetadataQueue.js","../../icecast-metadata-js/src/MetadataParser/IcyMetadataParser.js","../../icecast-metadata-js/src/MetadataParser/OggMetadataParser.js","../../icecast-metadata-js/src/IcecastReadableStream.js","../../icecast-metadata-player/src/IcecastMetadataPlayer.js","About/About.module.css","../../icecast-metadata-js/browser.js","../../icecast-metadata-js/src/MetadataParser/Stats.js","Player/Player.module.css","../../icecast-metadata-js/src/MetadataParser/DualMetadataParser.js","StationSelector/StationSelector.module.css","Player/play.svg","Player/pause.svg","Player/Player.jsx","StationSelector/StationSelector.jsx","About/About.jsx","App.js","serviceWorker.js","index.js"],"names":["MetadataParser","require","IcyMetadataParser","OggMetadataParser","DualMetadataParser","IcecastMetadataReader","metadataTypes","rest","hasIcy","includes","hasOgg","this","_metadataParser","chunk","iterator","readAll","asyncIterator","asyncReadAll","icyMetaInt","string","parseIcyMetadata","module","exports","Decoder","TextDecoder","Stats","noOp","onStream","onMetadata","_remainingData","_currentPosition","_buffer","Uint8Array","_stats","_decoder","_onStream","_onMetadata","_onStreamPromise","Promise","resolve","_onMetadataPromise","_generator","_passThroughParser","next","Infinity","_getNextValue","_sendStream","i","value","stream","addStreamBytes","length","streamPayload","stats","metadata","metadataPayload","minLength","_readData","_concatBuffers","subarray","addBytes","data","addCurrentBytesRemaining","buf1","buf2","result","set","IcecastMetadataQueue","icyBr","onMetadataUpdate","onMetadataEnqueue","_icyBr","_onMetadataUpdate","_onMetadataEnqueue","_isInitialMetadata","_metadataQueue","timestampOffset","timestamp","_enqueueMetadata","getTimeByBytes","currentStreamPosition","bytesRead","forEach","clearTimeout","_timeoutId","push","_dequeueMetadata","setTimeout","shift","map","icyDetectionTimeout","_icyMetaInt","_icyDetectionTimeout","_icyParser","_hasIcyMetadata","_getStream","_getMetadataLength","_getMetadata","console","warn","METADATA_SEARCH","startTime","Date","now","metaInt","currentStreamBytesRemaining","addMetadataLengthBytes","currentMetadataBytesRemaining","addMetadataBytes","_sendMetadata","decode","metadataString","matchAll","match","params","_oggParser","_hasOggPage","_identifyCodec","codecMatcher","offset","DataView","from","buffer","getUint32","matchString","bytes","String","fromCharCode","baseOggPage","_matchBytes","oggPageSegments","reduce","acc","octet","regex","_readVorbisComment","vendorStringLength","_getUint32","vendorString","commentListLength","comments","commentLength","comment","delimiter","indexOf","key","toUpperCase","val","VENDOR_STRING","IcecastReadableStream","response","icecast","readerIterator","body","start","controller","parseInt","headers","get","enqueue","close","_icecast","readableStream","reader","getReader","Symbol","read","ReadableStream","ISOBMFFAudioWrapper","default","STOPPED","PLAYING","IcecastMetadataPlayer","endpoint","options","_endpoint","_audioElement","audioElement","Audio","_onError","onError","_metadataTypes","_state","_icecastReadableStream","_icecastMetadataQueue","_createMediaSource","addEventListener","stop","once","play","_fetchStream","then","res","_getOnStream","addMetadata","_sourceBuffer","currentTime","startReading","catch","e","purgeMetadataQueue","pause","name","message","error","_fallbackToAudioSrc","_controller","abort","messages","_logError","src","removeAttribute","load","_mediaSource","MediaSource","URL","createObjectURL","mimeType","readyState","addSourceBuffer","mode","_createSourceBuffer","sourceBuffers","appendBuffer","_waitForSourceBuffer","remove","AbortController","fetchStream","fetch","method","cache","signal","filter","isobmff","isTypeSupported","_appendSourceBuffer","fragment","Error","metadataQueue","_totalBytesRead","_streamBytesRead","_metadataLengthBytesRead","_metadataBytesRead","_currentBytesRemaining","_currentStreamBytesRemaining","_currentMetadataBytesRemaining","totalBytesRead","streamBytesRead","metadataLengthBytesRead","metadataBytesRead","currentBytesRemaining","_oggMetadataParser","_icyMetadataParser","oggValue","_extends","Object","assign","target","arguments","source","prototype","hasOwnProperty","call","apply","_objectWithoutProperties","excluded","sourceKeys","keys","_objectWithoutPropertiesLoose","getOwnPropertySymbols","sourceSymbolKeys","propertyIsEnumerable","_ref2","fill","d","SvgPlay","_ref","svgRef","title","titleId","props","xmlns","viewBox","ref","id","ForwardRef","SvgPause","SELECT_OR_PLAY","LOADING","ICECAST_METADATA_JS_DEMO","Player","station","useState","audioHeight","audioWidth","setSpectrumSize","meters","setMeters","metadataPlayer","setMetadataPlayer","useCallback","useEffect","playing","player","meta","log","removeEventListener","useMetadataPlayer","isPlaying","toggle","StreamTitle","TITLE","document","useLayoutEffect","updateSize","getElementById","Math","floor","clientWidth","clientHeight","window","className","styles","spectrum","height","width","audioEle","capColor","capHeight","meterWidth","meterCount","meterColor","color","gap","disabled","button","onClick","ARTIST","link","visitStation","href","rel","Station","changeStation","type","stationRadio","onChange","stationLabel","htmlFor","stationName","codecInfo","codec","join","stationDescription","description","StationSelector","stations","idx","About","about","mainLink","headerLink","style","fontWeight","process","App","setStation","header","footer","Boolean","location","hostname","ReactDOM","render","StrictMode","navigator","serviceWorker","ready","registration","unregister"],"mappings":"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","file":"static/js/main.7f795899.chunk.js","sourcesContent":["/* Copyright 2020 Ethan Halsall\n    This file is part of icecast-metadata-js.\n\n    icecast-metadata-js free software: you can redistribute it and/or modify\n    it under the terms of the GNU Lesser General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    icecast-metadata-js distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License\n    along with this program.  If not, see <https://www.gnu.org/licenses/>\n*/\n\nconst MetadataParser = require(\"./MetadataParser/MetadataParser\");\nconst IcyMetadataParser = require(\"./MetadataParser/IcyMetadataParser\");\nconst OggMetadataParser = require(\"./MetadataParser/OggMetadataParser\");\nconst DualMetadataParser = require(\"./MetadataParser/DualMetadataParser\");\n\nclass IcecastMetadataReader {\n  /**\n   * @description Splits Icecast raw response into stream bytes and metadata key / value pairs.\n   * @param {number} IcecastMetadataReader.icyMetaInt Interval in bytes of metadata updates returned by the Icecast server\n   * @param {number} IcecastMetadataReader.icyDetectionTimeout Duration in milliseconds to search for metadata if icyMetaInt isn't passed in\n   * @param {Array} IcecastMetadataReader.metadataTypes Types of metadata to capture: \"icy\" and/or \"ogg\"\n   *\n   * @callback onMetadata\n   * @param {object} value Object containing Metadata and Statistics\n   * @param {object} metadata Object containing the metadata received.\n   * @param {string} [metadata.StreamTitle] (ICY) Title of the metadata update.\n   * @param {string} [metadata.StreamUrl] (ICY) Url (usually album art) of the metadata update.\n   * @param {string} [metadata.TITLE] (OGG) Url Title of the metadata update.\n   * @param {object} stats Object containing statistics on how many bytes were read and the current read position.\n   *\n   * @callback onStream\n   * @param {object} value Object containing Stream data and Statistics\n   * @param {Uint8Array} stream Object containing the stream buffer.\n   * @param {object} stats Object containing statistics on how many bytes were read and the current read position.\n   */\n  constructor({ metadataTypes = [\"icy\"], ...rest } = {}) {\n    const hasIcy = metadataTypes.includes(\"icy\");\n    const hasOgg = metadataTypes.includes(\"ogg\");\n\n    if (hasIcy && hasOgg) this._metadataParser = new DualMetadataParser(rest);\n    else if (hasOgg) this._metadataParser = new OggMetadataParser(rest);\n    else if (hasIcy) this._metadataParser = new IcyMetadataParser(rest);\n    else this._metadataParser = new MetadataParser(rest);\n  }\n\n  /**\n   * @description Parses an ICY metadata string into key value pairs.\n   * @param {string} metadataString ICY formatted metadata string. (i.e. \"StreamTitle='A Title';\")\n   * @returns {object} Parsed metadata key value pairs. (i.e. {StreamTitle: \"A Title\"})\n   */\n  static parseIcyMetadata(string) {\n    return IcyMetadataParser.parseIcyMetadata(string);\n  }\n\n  /**\n   * @description Gets the ICY metadata interval for this instance.\n   * @returns {number} ICY metadata interval in bytes.\n   */\n  get icyMetaInt() {\n    return this._metadataParser.icyMetaInt;\n  }\n\n  /**\n   * @description Returns an iterator that yields stream or metadata.\n   * @param {Uint8Array} chunk Next chunk of data to read\n   * @returns {Iterator} Iterator that operates over a raw icecast response.\n   * @yields {object} Object containing stream or metadata.\n   */\n  *iterator(chunk) {\n    yield* this._metadataParser.iterator(chunk);\n  }\n\n  /**\n   * @description Reads all data in the passed in chunk and calls the onStream and onMetadata callbacks.\n   * @param {Uint8Array} chunk Next chunk of data to read\n   */\n  readAll(chunk) {\n    this._metadataParser.readAll(chunk);\n  }\n\n  /**\n   * @description Returns an async iterator that yields stream or metadata and awaits the onStream and onMetadata callbacks.\n   * @param {Uint8Array} chunk Next chunk of data to read\n   * @returns {IterableIterator} Iterator that operates over a raw icecast response.\n   * @yields {object} Object containing stream or metadata.\n   */\n  async *asyncIterator(chunk) {\n    return yield* this._metadataParser.asyncIterator(chunk);\n  }\n\n  /**\n   * @description Reads all data in the chunk and awaits the onStream and onMetadata callbacks.\n   * @param {Uint8Array} chunk Next chunk of data to read\n   */\n  async asyncReadAll(chunk) {\n    return this._metadataParser.asyncReadAll(chunk);\n  }\n}\n\nmodule.exports = IcecastMetadataReader;\n","/* Copyright 2020 Ethan Halsall\n    This file is part of icecast-metadata-js.\n\n    icecast-metadata-js free software: you can redistribute it and/or modify\n    it under the terms of the GNU Lesser General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    icecast-metadata-js distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License\n    along with this program.  If not, see <https://www.gnu.org/licenses/>\n*/\n\nconst Decoder = require(\"util\").TextDecoder || TextDecoder;\nconst Stats = require(\"./Stats\");\n\nconst noOp = () => {};\n\n/**\n * @description Passthrough parser\n * @protected\n * @see IcecastMetadataReader\n */\n\nclass MetadataParser {\n  constructor({ onStream = noOp, onMetadata = noOp }) {\n    this._remainingData = 0;\n    this._currentPosition = 0;\n    this._buffer = new Uint8Array(0);\n    this._stats = new Stats();\n    this._decoder = new Decoder(\"utf-8\");\n\n    this._onStream = onStream;\n    this._onMetadata = onMetadata;\n    this._onStreamPromise = Promise.resolve();\n    this._onMetadataPromise = Promise.resolve();\n\n    this._generator = this._passThroughParser();\n    this._generator.next();\n  }\n\n  *_passThroughParser() {\n    this._remainingData = Infinity;\n    while (true) {\n      yield* this._sendStream(yield* this._getNextValue());\n    }\n  }\n\n  static _concatBuffers(buf1, buf2) {\n    const result = new Uint8Array(buf1.length + buf2.length);\n    result.set(buf1);\n    result.set(buf2, buf1.length);\n    return result;\n  }\n\n  *iterator(chunk) {\n    for (\n      let i = this._generator.next(chunk);\n      i.value;\n      i = this._generator.next()\n    ) {\n      yield i.value;\n    }\n  }\n\n  readAll(chunk) {\n    for (\n      let i = this._generator.next(chunk);\n      i.value;\n      i = this._generator.next()\n    ) {}\n  }\n\n  async *asyncIterator(chunk) {\n    for (\n      let i = this._generator.next(chunk);\n      i.value;\n      i = this._generator.next()\n    ) {\n      await this._onStreamPromise;\n      await this._onMetadataPromise;\n      yield i.value;\n    }\n  }\n\n  async asyncReadAll(chunk) {\n    for (\n      let i = this._generator.next(chunk);\n      i.value;\n      i = this._generator.next()\n    ) {\n      await this._onStreamPromise;\n      await this._onMetadataPromise;\n    }\n  }\n\n  *_sendStream(stream) {\n    this._stats.addStreamBytes(stream.length);\n\n    const streamPayload = { stream, stats: this._stats.stats };\n\n    this._onStreamPromise = this._onStream(streamPayload);\n    yield streamPayload;\n  }\n\n  *_sendMetadata(metadata) {\n    const metadataPayload = {\n      metadata,\n      stats: this._stats.stats,\n    };\n\n    this._onMetadataPromise = this._onMetadata(metadataPayload);\n    yield metadataPayload;\n  }\n\n  *_getNextValue(minLength = 0) {\n    if (this._currentPosition === this._buffer.length) {\n      this._buffer = yield* this._readData();\n      this._currentPosition = 0;\n    }\n\n    while (this._buffer.length - this._currentPosition < minLength) {\n      this._buffer = MetadataParser._concatBuffers(\n        this._buffer,\n        yield* this._readData()\n      );\n    }\n\n    const value = this._buffer.subarray(\n      this._currentPosition,\n      (minLength || this._remainingData) + this._currentPosition\n    );\n\n    this._stats.addBytes(value.length);\n    this._remainingData -= value.length;\n    this._currentPosition += value.length;\n\n    return value;\n  }\n\n  *_readData() {\n    let data;\n\n    do {\n      data = yield; // if out of data, accept new data in the .next() call\n    } while (!data || data.length === 0);\n\n    this._stats.addCurrentBytesRemaining(data.length);\n    return data;\n  }\n}\n\nmodule.exports = MetadataParser;\n","// extracted by mini-css-extract-plugin\nmodule.exports = {\"header\":\"App_header__3ZZ1n\",\"footer\":\"App_footer__29Fsv\"};","/* Copyright 2020 Ethan Halsall\n    This file is part of icecast-metadata-js.\n\n    icecast-metadata-js free software: you can redistribute it and/or modify\n    it under the terms of the GNU Lesser General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    icecast-metadata-js distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License\n    along with this program.  If not, see <https://www.gnu.org/licenses/>\n*/\n\nconst noOp = () => {};\n\nclass IcecastMetadataQueue {\n  /**\n   * @description Schedules updates up to the millisecond for Icecast Metadata from the response body of an Icecast stream mountpoint\n   * @description The accuracy of metadata updates is a direct relationship of the icyMetaInt\n   * @param {Object} IcecastMetadataQueue constructor parameter\n   * @param {number} [IcecastMetadataQueue.icyBr] Bitrate of audio stream used to increase accuracy when to updating metadata\n   * @param {onMetadataUpdate} [IcecastMetadataQueue.onMetadataUpdate] Callback executed when metadata is scheduled to update\n   * @param {onMetadataEnqueue} [IcecastMetadataQueue.onMetadataEnqueue] Callback executed when metadata is enqueued\n   *\n   * @callback onMetadataUpdate\n   * @param {Object} metadata Object containing all metadata received.\n   * @param {string} [metadata.StreamTitle] Title of the metadata update.\n   * @param {string} [metadata.StreamUrl] Url (usually album art) of the metadata update.\n   * @param {number} timestampOffset Total time buffered when the metadata was added\n   * @param {number} timestamp Current time of the audio player when the metadata was added\n   *\n   * @callback onMetadataEnqueue\n   * @param {Object} metadata Object containing all metadata received.\n   * @param {string} [metadata.StreamTitle] Title of the metadata update.\n   * @param {string} [metadata.StreamUrl] Url (usually album art) of the metadata update.\n   * @param {number} timestampOffset Total time buffered when the metadata was added\n   * @param {number} timestamp Current time of the audio player when the metadata was added\n   *\n   */\n  constructor({ icyBr, onMetadataUpdate = noOp, onMetadataEnqueue = noOp }) {\n    this._icyBr = icyBr;\n    this._onMetadataUpdate = onMetadataUpdate;\n    this._onMetadataEnqueue = onMetadataEnqueue;\n    this._isInitialMetadata = true;\n    this._metadataQueue = [];\n  }\n\n  /**\n   * @description Returns the metadata queued for updates\n   * @type {{metadata: string, time: number}[]} Queued metadata\n   */\n  get metadataQueue() {\n    return this._metadataQueue.map(({ _timeoutId, ...rest }) => rest);\n  }\n\n  /**\n   *\n   * @param {object} metadata Metadata object returned from IcecastMetadataReader\n   * @param {number} timestampOffset Total buffered audio in seconds\n   * @param {number} [timestamp] Current time in the audio player\n   */\n  addMetadata({ metadata, stats }, timestampOffset, timestamp = 0) {\n    /**\n     * Metadata time is derived from the total number of stream bytes read\n     * since the latest buffer input. The buffer offset should be the total\n     * seconds of audio in the player buffer when the metadata was read.\n     */\n    this._enqueueMetadata(\n      metadata,\n      timestampOffset,\n      timestamp + this.getTimeByBytes(stats.currentStreamPosition)\n    );\n  }\n\n  /**\n   * @description Calculates audio stream length based on bitrate\n   * @param {number} bytesRead Number of bytes\n   * @type {number} Seconds\n   */\n  getTimeByBytes(bytesRead) {\n    return this._icyBr ? bytesRead / (this._icyBr * 125) : 0;\n  }\n\n  /**\n   * @description Clears all metadata updates and empties the queue\n   */\n  purgeMetadataQueue() {\n    this._metadataQueue.forEach((i) => clearTimeout(i._timeoutId));\n    this._metadataQueue = [];\n  }\n\n  _enqueueMetadata(metadata, timestampOffset, timestamp) {\n    const metadataPayload = {\n      metadata,\n      timestampOffset,\n      timestamp,\n    };\n\n    this._metadataQueue.push(metadataPayload);\n    this._onMetadataEnqueue(metadata, timestampOffset, timestamp);\n\n    if (this._isInitialMetadata) {\n      this._dequeueMetadata();\n      this._isInitialMetadata = false;\n    } else {\n      metadataPayload._timeoutId = setTimeout(() => {\n        this._dequeueMetadata();\n      }, (timestampOffset - timestamp) * 1000); // trigger timeout relative to play position\n    }\n  }\n\n  _dequeueMetadata() {\n    const {\n      metadata,\n      timestampOffset,\n      timestamp,\n    } = this._metadataQueue.shift();\n    this._onMetadataUpdate(metadata, timestampOffset, timestamp);\n  }\n}\n\nmodule.exports = IcecastMetadataQueue;\n","/* Copyright 2020 Ethan Halsall\n    This file is part of icecast-metadata-js.\n\n    icecast-metadata-js free software: you can redistribute it and/or modify\n    it under the terms of the GNU Lesser General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    icecast-metadata-js distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License\n    along with this program.  If not, see <https://www.gnu.org/licenses/>\n*/\n\nconst MetadataParser = require(\"./MetadataParser\");\n\n/**\n * @description Parses ICY metadata from an Icecast stream\n * @protected\n * @see IcecastMetadataReader\n */\n\nclass IcyMetadataParser extends MetadataParser {\n  constructor({ icyMetaInt, icyDetectionTimeout = 2000, ...rest }) {\n    super(rest);\n\n    this._icyMetaInt = icyMetaInt;\n    this._icyDetectionTimeout = icyDetectionTimeout;\n\n    this._generator = this._icyParser();\n    this._generator.next();\n  }\n\n  *_icyParser() {\n    if (yield* this._hasIcyMetadata()) {\n      do {\n        this._remainingData = this._icyMetaInt;\n        yield* this._getStream();\n        yield* this._getMetadataLength();\n        if (this._remainingData) yield* this._getMetadata();\n      } while (true);\n    }\n\n    this._remainingData = Infinity;\n    yield* this._getStream();\n  }\n\n  static parseIcyMetadata(metadataString) {\n    /**\n     * Metadata is a string of key='value' pairs delimited by a semicolon.\n     * The string is a fixed length and any unused bytes at the end are 0x00.\n     * i.e. \"StreamTitle='The Stream Title';StreamUrl='https://example.com';\\0\\0\\0\\0\\0\\0\"\n     */\n\n    const metadata = {};\n    // [{key: \"StreamTitle\", val: \"The Stream Title\"}, {key: \"StreamUrl\", val: \"https://example.com\"}]\n    for (let match of metadataString.matchAll(\n      /(?<key>[^\\0]+?)='(?<val>[^\\0]*?)(;$|';|'$|$)/g\n    )) {\n      metadata[match[\"groups\"][\"key\"]] = match[\"groups\"][\"val\"];\n    }\n    // {StreamTitle: \"The Stream Title\", StreamUrl: \"https://example.com\"}\n    return metadata;\n  }\n\n  get icyMetaInt() {\n    return this._icyMetaInt;\n  }\n\n  *_hasIcyMetadata() {\n    if (this._icyMetaInt > 0) return true;\n    if (!this._icyDetectionTimeout) return false;\n\n    console.warn(\n      \"icecast-metadata-js\",\n      \"\\n  Passed in Icy-MetaInt is invalid. Attempting to detect ICY Metadata.\",\n      \"\\n  See https://github.com/eshaz/icecast-metadata-js for information on how to properly request ICY Metadata.\"\n    );\n\n    // prettier-ignore\n    const METADATA_SEARCH = [null,83,116,114,101,97,109,84,105,116,108,101,61]; // StreamTitle=\n    const startTime = Date.now();\n    let metaInt = 0;\n\n    while (startTime + this._icyDetectionTimeout > Date.now()) {\n      this._buffer = MetadataParser._concatBuffers(\n        this._buffer,\n        yield* this._readData()\n      );\n\n      // search for metadata\n      detectMetadata: while (\n        metaInt <\n        this._buffer.length - METADATA_SEARCH.length\n      ) {\n        for (let i = 1; i < METADATA_SEARCH.length; i++) {\n          if (this._buffer[i + metaInt] !== METADATA_SEARCH[i]) {\n            metaInt++;\n            continue detectMetadata;\n          }\n        }\n\n        // found metadata\n        console.warn(\n          \"icecast-metadata-js\",\n          `\\n  Found ICY Metadata! Setting Icy-MetaInt to ${metaInt}.`\n        );\n        this._icyMetaInt = metaInt;\n        return true;\n      }\n    }\n\n    // prettier-ignore\n    console.warn(\n      \"icecast-metadata-js\",\n      `\\n  ICY Metadata not detected after searching ${this._buffer.length} bytes for ${(Date.now() - startTime) / 1000} seconds.`,\n      \"\\n  Assuming stream does not contain ICY metadata. Audio errors will occur if there is ICY metadata.\"\n    );\n    return false;\n  }\n\n  *_getStream() {\n    this._stats.currentStreamBytesRemaining = this._remainingData;\n\n    while (this._remainingData) {\n      yield* this._sendStream(yield* super._getNextValue());\n    }\n  }\n\n  *_getMetadataLength() {\n    this._remainingData = 1;\n\n    do {\n      this._remainingData = (yield* this._getNextValue())[0] * 16;\n    } while (this._remainingData === 1);\n\n    this._stats.addMetadataLengthBytes(1);\n  }\n\n  *_getMetadata() {\n    this._stats.currentMetadataBytesRemaining = this._remainingData;\n\n    const metadata = yield* this._getNextValue(this._remainingData);\n    this._stats.addMetadataBytes(metadata.length);\n\n    yield* this._sendMetadata(\n      IcyMetadataParser.parseIcyMetadata(this._decoder.decode(metadata))\n    );\n  }\n}\n\nmodule.exports = IcyMetadataParser;\n","/* Copyright 2020 Ethan Halsall\n    This file is part of icecast-metadata-js.\n\n    icecast-metadata-js free software: you can redistribute it and/or modify\n    it under the terms of the GNU Lesser General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    icecast-metadata-js distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License\n    along with this program.  If not, see <https://www.gnu.org/licenses/>\n*/\n\nconst MetadataParser = require(\"./MetadataParser\");\n\n/**\n * @description Parses OGG metadata from an Icecast stream\n * @protected\n * @see IcecastMetadataReader\n */\nclass OggMetadataParser extends MetadataParser {\n  constructor(params) {\n    super(params);\n\n    this._generator = this._oggParser();\n    this._generator.next();\n  }\n\n  *_oggParser() {\n    if (yield* this._hasOggPage()) {\n      const codecMatcher = yield* this._identifyCodec();\n      if (codecMatcher) {\n        while (yield* this._hasOggPage()) {\n          yield* this._getMetadata(codecMatcher);\n          yield* this._getStream();\n        }\n      }\n    }\n\n    this._remainingData = Infinity;\n    yield* this._getStream();\n  }\n\n  _getUint32(data, offset = 0) {\n    return new DataView(\n      Uint8Array.from([...data.subarray(offset, offset + 4)]).buffer\n    ).getUint32(0, true);\n  }\n\n  _matchBytes(matchString, bytes) {\n    return String.fromCharCode(...bytes).match(matchString);\n  }\n\n  *_hasOggPage() {\n    const baseOggPage = yield* this._getNextValue(27); // OGG Page header without page segments\n    // Bytes (1-4 of 28)\n    // Frame sync (must equal OggS): `AAAAAAAA|AAAAAAAA|AAAAAAAA|AAAAAAAA`:\n    // Byte (6 of 28)\n    // * `00000...`: All zeros\n    if (\n      this._matchBytes(/OggS/, baseOggPage.subarray(0, 4)) &&\n      !(baseOggPage[5] & 0b11111000)\n    ) {\n      // Byte (27 of 28)\n      // * `JJJJJJJJ`: Number of page segments in the segment table\n      const oggPageSegments = yield* this._getNextValue(baseOggPage[26]);\n\n      this._remainingData = oggPageSegments.reduce(\n        (acc, octet) => acc + octet,\n        0\n      );\n      return true;\n    } else {\n      console.warn(\n        \"icecast-metadata-js\",\n        \"\\n  This stream is not an OGG stream. No OGG metadata will be returned.\",\n        \"\\n  See https://github.com/eshaz/icecast-metadata-js for information on OGG metadata.\"\n      );\n      return false;\n    }\n  }\n\n  *_identifyCodec() {\n    const data = yield* this._getNextValue(8);\n\n    yield* this._getStream();\n\n    if (this._matchBytes(/\\x7fFLAC/, data.subarray(0, 5))) {\n      return { regex: /^[\\x84|\\x04]/, length: 4 };\n    } else if (this._matchBytes(/OpusHead/, data.subarray(0, 8))) {\n      return { regex: /OpusTags/, length: 8 };\n    } else if (this._matchBytes(/\\x01vorbis/, data.subarray(0, 7))) {\n      return { regex: /\\x03vorbis/, length: 7 };\n    }\n  }\n\n  *_getMetadata({ regex, length }) {\n    if (this._matchBytes(regex, yield* this._getNextValue(length))) {\n      yield* this._sendMetadata(yield* this._readVorbisComment());\n    }\n  }\n\n  *_getStream() {\n    while (this._remainingData) {\n      yield* this._getNextValue();\n    }\n  }\n\n  *_getNextValue(length) {\n    const value = yield* super._getNextValue(length);\n\n    yield* this._sendStream(value);\n    return value;\n  }\n\n  *_readData() {\n    const data = yield* super._readData();\n    this._stats.currentStreamBytesRemaining = data.length;\n    return data;\n  }\n\n  *_readVorbisComment() {\n    /*\n    1) [vendor_length] = read an unsigned integer of 32 bits\n    2) [vendor_string] = read a UTF-8 vector as [vendor_length] octets\n    3) [user_comment_list_length] = read an unsigned integer of 32 bits\n    4) iterate [user_comment_list_length] times {\n       5) [length] = read an unsigned integer of 32 bits\n       6) this iteration's user comment = read a UTF-8 vector as [length] octets\n    }\n    7) [framing_bit] = read a single bit as boolean\n    8) if ( [framing_bit] unset or end of packet ) then ERROR\n    9) done.\n    */\n    const vendorStringLength = this._getUint32(yield* this._getNextValue(4));\n    this._stats.addMetadataBytes(4);\n\n    const vendorString = this._decoder.decode(\n      yield* this._getNextValue(vendorStringLength)\n    );\n    this._stats.addMetadataBytes(vendorStringLength);\n\n    const commentListLength = this._getUint32(yield* this._getNextValue(4));\n    this._stats.addMetadataBytes(4);\n\n    const comments = [];\n    for (let i = 0; i < commentListLength; i++) {\n      const commentLength = yield* this._getNextValue(4);\n      this._stats.addMetadataBytes(4);\n\n      comments.push(yield* this._getNextValue(this._getUint32(commentLength)));\n      this._stats.addMetadataBytes(comments[comments.length - 1].length);\n    }\n\n    this._stats.currentMetadataBytesRemaining = 0;\n\n    return comments.reduce(\n      (metadata, comment) => {\n        const delimiter = comment.indexOf(0x3d);\n        // prettier-ignore\n        const key = String.fromCharCode(...comment.subarray(0, delimiter)).toUpperCase();\n        const val = this._decoder.decode(comment.subarray(delimiter + 1));\n\n        metadata[key] = metadata[key] ? `${metadata[key]}; ${val}` : val;\n        return metadata;\n      },\n      { VENDOR_STRING: vendorString }\n    );\n  }\n}\n\nmodule.exports = OggMetadataParser;\n","/* Copyright 2020 Ethan Halsall\n    This file is part of icecast-metadata-js.\n\n    icecast-metadata-js free software: you can redistribute it and/or modify\n    it under the terms of the GNU Lesser General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    icecast-metadata-js distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License\n    along with this program.  If not, see <https://www.gnu.org/licenses/>\n*/\n\nconst IcecastMetadataReader = require(\"./IcecastMetadataReader\");\n\nconst noOp = () => {};\n\n/**\n * @description Browser ReadableStream wrapper for IcecastMetadataReader\n * @extends ReadableStream\n */\nclass IcecastReadableStream extends ReadableStream {\n  /**\n   *\n   * @param {ReadableStream} response ReadableStream for raw Icecast response data\n   * @param {object} options Configuration options for IcecastMetadataReader\n   * @see IcecastMetadataReader for information on the options parameter\n   */\n  constructor(response, { icyMetaInt, onStream = noOp, ...rest }) {\n    const readerIterator = IcecastReadableStream.asyncIterator(response.body);\n    let icecast;\n\n    super({\n      async start(controller) {\n        icecast = new IcecastMetadataReader({\n          ...rest,\n          icyMetaInt:\n            parseInt(response.headers.get(\"Icy-MetaInt\")) || icyMetaInt,\n          onStream: async (value) => {\n            controller.enqueue(value.stream);\n            return onStream(value);\n          },\n        });\n\n        for await (const chunk of readerIterator) {\n          await icecast.asyncReadAll(chunk);\n        }\n\n        controller.close();\n      },\n    });\n\n    this._icecast = icecast;\n  }\n\n  get icyMetaInt() {\n    return this._icecast.icyMetaInt;\n  }\n\n  /**\n   * @description Creates an async iterator from this ReadableStream.\n   * @returns {Symbol.asyncIterator} Async Iterator for this ReadableStream.\n   */\n  async startReading() {\n    for await (const i of IcecastReadableStream.asyncIterator(this)) {\n    }\n  }\n\n  /**\n   * @description Wraps a ReadableStream as an Async Iterator.\n   * @param {ReadableStream} readableStream ReadableStream to convert to AsyncIterator\n   * @returns {Symbol.asyncIterator} Async Iterator that wraps the ReadableStream\n   */\n  static asyncIterator(readableStream) {\n    const reader = readableStream.getReader();\n    return {\n      [Symbol.asyncIterator]: () => ({\n        next: () => reader.read(),\n      }),\n    };\n  }\n}\n\nmodule.exports = IcecastReadableStream;\n","/**\n * @license\n * @see https://github.com/eshaz/icecast-metadata-js\n * @copyright 2021 Ethan Halsall\n *  This file is part of icecast-metadata-player.\n *\n *  icecast-metadata-player free software: you can redistribute it and/or modify\n *  it under the terms of the GNU Lesser General Public License as published by\n *  the Free Software Foundation, either version 3 of the License, or\n *  (at your option) any later version.\n *\n *  icecast-metadata-player distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU Lesser General Public License for more details.\n *\n *  You should have received a copy of the GNU Lesser General Public License\n *  along with this program.  If not, see <https://www.gnu.org/licenses/>\n */\nconst {\n  IcecastReadableStream,\n  IcecastMetadataQueue,\n} = require(\"icecast-metadata-js\");\nconst ISOBMFFAudioWrapper = require(\"isobmff-audio\").default;\n\nconst BUFFER = 2; // seconds of audio to store in SourceBuffer\nconst STOPPED = Symbol();\nconst PLAYING = Symbol();\n\nconst noOp = () => {};\n\nclass IcecastMetadataPlayer {\n  constructor(endpoint, options = {}) {\n    this._endpoint = endpoint;\n    this._audioElement = options.audioElement || new Audio();\n    this._icyMetaInt = options.icyMetaInt;\n    this._icyDetectionTimeout = options.icyDetectionTimeout;\n    this._onStream = options.onStream || noOp;\n    this._onError = options.onError || noOp;\n    this._metadataTypes = options.metadataTypes || [\"icy\"];\n\n    this._state = STOPPED;\n    this._icecastReadableStream = {};\n    this._icecastMetadataQueue = new IcecastMetadataQueue({\n      onMetadataUpdate: options.onMetadata || noOp,\n      onMetadataEnqueue: options.onMetadataEnqueue || noOp,\n    });\n\n    this._createMediaSource();\n  }\n\n  get audioElement() {\n    return this._audioElement;\n  }\n\n  get icyMetaInt() {\n    return this._icecastReadableStream.icyMetaInt;\n  }\n\n  get metadataQueue() {\n    return this._icecastMetadataQueue.metadataQueue;\n  }\n\n  get playing() {\n    return this._state === PLAYING;\n  }\n\n  play() {\n    if (this._state === STOPPED) {\n      this._state = PLAYING;\n      this._createMediaSource();\n\n      // allow for remote control pause\n      this._audioElement.addEventListener(\n        \"pause\",\n        () => {\n          this.stop();\n          this._createMediaSource();\n        },\n        { once: true }\n      );\n\n      this._audioElement.addEventListener(\n        \"canplay\",\n        () => {\n          this._audioElement.play();\n        },\n        { once: true }\n      );\n\n      this._fetchStream()\n        .then(async (res) => {\n          const onStream = this._getOnStream(res.headers.get(\"content-type\"));\n\n          this._icecastReadableStream = new IcecastReadableStream(res, {\n            onMetadata: (value) =>\n              this._icecastMetadataQueue.addMetadata(\n                value,\n                (this._sourceBuffer && this._sourceBuffer.timestampOffset) || 0,\n                this._audioElement.currentTime\n              ),\n            onStream,\n            metadataTypes: this._metadataTypes,\n            icyMetaInt: this._icyMetaInt,\n            icyDetectionTimeout: this._icyDetectionTimeout,\n          });\n\n          await this._icecastReadableStream.startReading();\n        })\n        .catch(async (e) => {\n          this._icecastMetadataQueue.purgeMetadataQueue();\n          this._audioElement.pause();\n          this._sourceBuffer = null;\n\n          if (e.name !== \"AbortError\" && e.message !== \"Error in body stream\") {\n            console.error(e);\n            this._fallbackToAudioSrc();\n            this._state = STOPPED;\n          }\n        });\n    }\n  }\n\n  stop() {\n    if (this._state === PLAYING) {\n      this._state = STOPPED;\n      this._controller.abort();\n    }\n  }\n\n  _logError(...messages) {\n    console.warn(\n      \"icecast-metadata-js\",\n      messages.reduce((acc, message) => acc + \"\\n  \" + message, \"\")\n    );\n\n    this._onError(messages[0]);\n  }\n\n  _fallbackToAudioSrc() {\n    this._logError(\n      \"Falling back to HTML5 audio with no metadata updates. See the console for details on the error.\"\n    );\n\n    this._state = STOPPED;\n\n    this.play = () => {\n      if (this._state === STOPPED) {\n        this._state = PLAYING;\n        this._audioElement.src = this._endpoint;\n        this._audioElement.play();\n      }\n    };\n\n    this.stop = () => {\n      if (this._state === PLAYING) {\n        this._state = STOPPED;\n        this._audioElement.pause();\n        this._audioElement.removeAttribute(\"src\");\n        this._audioElement.load();\n      }\n    };\n\n    this.play();\n  }\n\n  _createMediaSource() {\n    this._sourceBuffer = null;\n    this._mediaSource = new MediaSource();\n    this._audioElement.src = URL.createObjectURL(this._mediaSource);\n  }\n\n  async _createSourceBuffer(mimeType) {\n    if (this._mediaSource.readyState === \"open\") {\n      this._sourceBuffer = this._mediaSource.addSourceBuffer(mimeType);\n      this._sourceBuffer.mode = \"sequence\";\n    } else {\n      await new Promise((resolve) => {\n        this._mediaSource.addEventListener(\n          \"sourceopen\",\n          () => {\n            this._sourceBuffer = this._mediaSource.addSourceBuffer(mimeType);\n            this._sourceBuffer.mode = \"sequence\";\n            resolve();\n          },\n          { once: true }\n        );\n      });\n    }\n  }\n\n  async _waitForSourceBuffer() {\n    return new Promise((resolve) => {\n      this._sourceBuffer.addEventListener(\"updateend\", resolve, { once: true });\n    });\n  }\n\n  async _appendSourceBuffer(chunk, mimeType) {\n    if (!this._sourceBuffer) await this._createSourceBuffer(mimeType);\n\n    if (this._mediaSource.sourceBuffers.length) {\n      this._sourceBuffer.appendBuffer(chunk);\n      await this._waitForSourceBuffer();\n\n      if (this._audioElement.currentTime > BUFFER) {\n        this._sourceBuffer.remove(0, this._audioElement.currentTime - BUFFER);\n        await this._waitForSourceBuffer();\n      }\n    }\n  }\n\n  async _fetchStream() {\n    this._controller = new AbortController();\n\n    const fetchStream = () =>\n      fetch(this._endpoint, {\n        method: \"GET\",\n        cache: \"no-store\",\n        headers: this._metadataTypes.includes(\"icy\")\n          ? { \"Icy-MetaData\": 1 }\n          : {},\n        signal: this._controller.signal,\n      });\n\n    return fetchStream().catch((e) => {\n      if (this._metadataTypes.includes(\"icy\") && e.name !== \"AbortError\") {\n        this._metadataTypes = this._metadataTypes.filter(\n          (metadata) => metadata !== \"icy\"\n        );\n        this._logError(\n          \"Network request failed, possibly due to a CORS issue. Trying again without ICY Metadata.\"\n        );\n        return fetchStream();\n      }\n      throw e;\n    });\n  }\n\n  _getOnStream(mimeType) {\n    const isobmff = new ISOBMFFAudioWrapper(mimeType);\n\n    if (MediaSource.isTypeSupported(mimeType)) {\n      return async ({ stream }) => this._appendSourceBuffer(stream, mimeType);\n    } else if (MediaSource.isTypeSupported(isobmff.mimeType)) {\n      return async ({ stream }) => {\n        for await (const fragment of isobmff.iterator(stream)) {\n          await this._appendSourceBuffer(fragment, isobmff.mimeType);\n        }\n      };\n    } else {\n      this._logError(\n        `Media Source Extensions API in your browser does not support ${mimeType} ${isobmff.mimeType}`,\n        \"See: https://caniuse.com/mediasource and https://developer.mozilla.org/en-US/docs/Web/API/Media_Source_Extensions_API\"\n      );\n\n      throw new Error(\"Unsupported Codec\");\n    }\n  }\n}\n\nmodule.exports = IcecastMetadataPlayer;\n","// extracted by mini-css-extract-plugin\nmodule.exports = {\"about\":\"About_about__2v-0B\",\"headerLink\":\"About_headerLink__3aZVt\",\"mainLink\":\"About_mainLink__1aSaU\",\"subLink\":\"About_subLink__n5KCY\",\"description\":\"About_description__3WN3o\",\"disclaimer\":\"About_disclaimer__2gOk6\"};","import IcecastMetadataQueue from \"./src/IcecastMetadataQueue\";\nimport IcecastMetadataReader from \"./src/IcecastMetadataReader\";\nimport IcecastReadableStream from \"./src/IcecastReadableStream\";\n\nexport { IcecastMetadataQueue, IcecastMetadataReader, IcecastReadableStream };\n","/* Copyright 2020 Ethan Halsall\n    This file is part of icecast-metadata-js.\n\n    icecast-metadata-js free software: you can redistribute it and/or modify\n    it under the terms of the GNU Lesser General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    icecast-metadata-js distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License\n    along with this program.  If not, see <https://www.gnu.org/licenses/>\n*/\n\nclass Stats {\n  constructor() {\n    this._totalBytesRead = 0;\n    this._streamBytesRead = 0;\n    this._metadataLengthBytesRead = 0;\n    this._metadataBytesRead = 0;\n\n    this._currentBytesRemaining = 0;\n    this._currentStreamBytesRemaining = 0;\n    this._currentMetadataBytesRemaining = 0;\n  }\n\n  get stats() {\n    return {\n      totalBytesRead: this._totalBytesRead,\n      streamBytesRead: this._streamBytesRead,\n      metadataLengthBytesRead: this._metadataLengthBytesRead,\n      metadataBytesRead: this._metadataBytesRead,\n      currentBytesRemaining: this._currentBytesRemaining,\n      currentStreamBytesRemaining: this._currentStreamBytesRemaining,\n      currentMetadataBytesRemaining: this._currentMetadataBytesRemaining,\n    };\n  }\n\n  set currentStreamBytesRemaining(bytes) {\n    this._currentStreamBytesRemaining += bytes;\n  }\n\n  set currentMetadataBytesRemaining(bytes) {\n    this._currentMetadataBytesRemaining = bytes;\n  }\n\n  addBytes(bytes) {\n    this._totalBytesRead += bytes;\n    this._currentBytesRemaining -= bytes;\n  }\n\n  addStreamBytes(bytes) {\n    this._streamBytesRead += bytes;\n    this._currentStreamBytesRemaining -= bytes;\n  }\n\n  addMetadataLengthBytes(bytes) {\n    this._metadataLengthBytesRead += bytes;\n  }\n\n  addMetadataBytes(bytes) {\n    this._metadataBytesRead += bytes;\n    this._currentMetadataBytesRemaining -= bytes;\n  }\n\n  addCurrentBytesRemaining(bytes) {\n    this._currentBytesRemaining += bytes;\n  }\n}\n\nmodule.exports = Stats;\n","// extracted by mini-css-extract-plugin\nmodule.exports = {\"spectrum\":\"Player_spectrum__1ThfC\",\"player\":\"Player_player__1vYfQ\",\"metadata\":\"Player_metadata__3j7ae\",\"button\":\"Player_button__297uW\",\"link\":\"Player_link__2k87w\",\"visitStation\":\"Player_visitStation__2xKeH\"};","/* Copyright 2020 Ethan Halsall\n    This file is part of icecast-metadata-js.\n\n    icecast-metadata-js free software: you can redistribute it and/or modify\n    it under the terms of the GNU Lesser General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    icecast-metadata-js distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License\n    along with this program.  If not, see <https://www.gnu.org/licenses/>\n*/\n\nconst IcyMetadataParser = require(\"./IcyMetadataParser\");\nconst OggMetadataParser = require(\"./OggMetadataParser\");\n\n/**\n * @description Parses ICY and OGG metadata from an Icecast stream\n * @protected\n * @see IcecastMetadataReader\n */\n\nclass DualMetadataParser {\n  constructor(params) {\n    const { onStream, ...rest } = params;\n    this._oggMetadataParser = new OggMetadataParser(params);\n    this._icyMetadataParser = new IcyMetadataParser(rest);\n  }\n\n  get icyMetaInt() {\n    return this._icyMetadataParser.icyMetaInt;\n  }\n\n  *iterator(chunk) {\n    for (const value of this._icyMetadataParser.iterator(chunk)) {\n      if (value.stream) {\n        yield* this._oggMetadataParser.iterator(value.stream);\n      } else {\n        yield value;\n      }\n    }\n  }\n\n  readAll(chunk) {\n    for (const value of this._icyMetadataParser.iterator(chunk)) {\n      if (value.stream) {\n        this._oggMetadataParser.readAll(value.stream);\n      }\n    }\n  }\n\n  async *asyncIterator(chunk) {\n    for await (const value of this._icyMetadataParser.asyncIterator(chunk)) {\n      if (value.stream) {\n        for await (const oggValue of this._oggMetadataParser.asyncIterator(\n          value.stream\n        )) {\n          yield oggValue;\n        }\n      } else {\n        yield value;\n      }\n    }\n  }\n\n  async asyncReadAll(chunk) {\n    for await (const value of this._icyMetadataParser.iterator(chunk)) {\n      if (value.stream) {\n        await this._oggMetadataParser.asyncReadAll(value.stream);\n      }\n    }\n  }\n}\n\nmodule.exports = DualMetadataParser;\n","// extracted by mini-css-extract-plugin\nmodule.exports = {\"station\":\"StationSelector_station__3a44c\",\"stationRadio\":\"StationSelector_stationRadio__1FTGQ\",\"stationLabel\":\"StationSelector_stationLabel__1DbUR\",\"stationName\":\"StationSelector_stationName__1hB_K\",\"stationDescription\":\"StationSelector_stationDescription__36TBn\",\"codecInfo\":\"StationSelector_codecInfo__JZjFy\"};","function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\nimport * as React from \"react\";\n\nvar _ref2 = /*#__PURE__*/React.createElement(\"path\", {\n  fill: \"#808080\",\n  d: \"M424.4 214.7L72.4 6.6C43.8-10.3 0 6.1 0 47.9V464c0 37.5 40.7 60.1 72.4 41.3l352-208c31.4-18.5 31.5-64.1 0-82.6z\"\n});\n\nfunction SvgPlay(_ref, svgRef) {\n  var title = _ref.title,\n      titleId = _ref.titleId,\n      props = _objectWithoutProperties(_ref, [\"title\", \"titleId\"]);\n\n  return /*#__PURE__*/React.createElement(\"svg\", _extends({\n    xmlns: \"http://www.w3.org/2000/svg\",\n    viewBox: \"0 0 448 512\",\n    ref: svgRef,\n    \"aria-labelledby\": titleId\n  }, props), title ? /*#__PURE__*/React.createElement(\"title\", {\n    id: titleId\n  }, title) : null, _ref2);\n}\n\nvar ForwardRef = /*#__PURE__*/React.forwardRef(SvgPlay);\nexport default __webpack_public_path__ + \"static/media/play.18e046c1.svg\";\nexport { ForwardRef as ReactComponent };","function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\nimport * as React from \"react\";\n\nvar _ref2 = /*#__PURE__*/React.createElement(\"path\", {\n  fill: \"#808080\",\n  d: \"M144 479H48c-26.5 0-48-21.5-48-48V79c0-26.5 21.5-48 48-48h96c26.5 0 48 21.5 48 48v352c0 26.5-21.5 48-48 48zm304-48V79c0-26.5-21.5-48-48-48h-96c-26.5 0-48 21.5-48 48v352c0 26.5 21.5 48 48 48h96c26.5 0 48-21.5 48-48z\"\n});\n\nfunction SvgPause(_ref, svgRef) {\n  var title = _ref.title,\n      titleId = _ref.titleId,\n      props = _objectWithoutProperties(_ref, [\"title\", \"titleId\"]);\n\n  return /*#__PURE__*/React.createElement(\"svg\", _extends({\n    xmlns: \"http://www.w3.org/2000/svg\",\n    viewBox: \"0 0 448 512\",\n    ref: svgRef,\n    \"aria-labelledby\": titleId\n  }, props), title ? /*#__PURE__*/React.createElement(\"title\", {\n    id: titleId\n  }, title) : null, _ref2);\n}\n\nvar ForwardRef = /*#__PURE__*/React.forwardRef(SvgPause);\nexport default __webpack_public_path__ + \"static/media/pause.50a7fb92.svg\";\nexport { ForwardRef as ReactComponent };","import React, {\n  useLayoutEffect,\n  useEffect,\n  useState,\n  useCallback,\n} from \"react\";\nimport AudioSpectrum from \"react-audio-spectrum\";\nimport IcecastMetadataPlayer from \"icecast-metadata-player\";\nimport { ReactComponent as Play } from \"./play.svg\";\nimport { ReactComponent as Pause } from \"./pause.svg\";\nimport styles from \"./Player.module.css\";\n\nconst SELECT_STATION = \"Select a station\";\nconst SELECT_OR_PLAY = \"Select a station or press play\";\nconst LOADING = \"Loading...\";\nconst VISIT_STATION = \"Visit this station at \";\nconst ICECAST_METADATA_JS_DEMO = \"Icecast Metadata JS Demo\";\n\nconst useMetadataPlayer = (station, onMetadata, audioElement) => {\n  const [metadataPlayer, setMetadataPlayer] = useState();\n\n  const toggle = () => (metadataPlayer?.playing ? stop() : play());\n\n  const play = useCallback(() => {\n    onMetadata(LOADING);\n    metadataPlayer.play();\n  }, [onMetadata, metadataPlayer]);\n\n  const stop = useCallback(() => {\n    onMetadata(SELECT_OR_PLAY);\n    metadataPlayer.stop();\n  }, [onMetadata, metadataPlayer]);\n\n  useEffect(() => {\n    if (metadataPlayer?.playing) {\n      onMetadata(SELECT_OR_PLAY);\n      metadataPlayer.stop();\n    }\n\n    if (station) {\n      const player = new IcecastMetadataPlayer(station.endpoint, {\n        onMetadata: (meta) => {\n          console.log(meta);\n          onMetadata(meta);\n        },\n        icyDetectionTimeout: 5000,\n        metadataTypes: station.metadataTypes,\n        audioElement,\n      });\n\n      onMetadata(LOADING);\n      player.play();\n\n      setMetadataPlayer(player);\n    }\n  }, [station]);\n\n  useEffect(() => {\n    audioElement.addEventListener(\"pause\", stop);\n    return () => audioElement.removeEventListener(\"pause\", stop);\n  }, [audioElement, stop]);\n\n  return [metadataPlayer?.playing, toggle];\n};\n\nconst Player = ({ station }) => {\n  const [audioElement] = useState(new Audio());\n  const [[audioHeight, audioWidth], setSpectrumSize] = useState([0, 0]);\n  const [meters, setMeters] = useState(0);\n\n  const [metadata, setMetadata] = useState(SELECT_STATION);\n  const [isPlaying, toggle] = useMetadataPlayer(\n    station,\n    setMetadata,\n    audioElement\n  );\n\n  useEffect(() => {\n    const title = metadata.StreamTitle || metadata.TITLE;\n    document.title = title\n      ? `${title} | ${ICECAST_METADATA_JS_DEMO}`\n      : ICECAST_METADATA_JS_DEMO;\n  }, [metadata]);\n\n  useLayoutEffect(() => {\n    const updateSize = () => {\n      const player = document.getElementById(\"player\");\n      setMeters(Math.floor(player.clientWidth / 32));\n      setSpectrumSize([player.clientHeight + 6, player.clientWidth]);\n    };\n    window.addEventListener(\"resize\", updateSize);\n    updateSize();\n    return () => window.removeEventListener(\"resize\", updateSize);\n  }, []);\n\n  return (\n    <div id={\"player\"} className={styles.player}>\n      <div className={styles.spectrum}>\n        <AudioSpectrum\n          height={audioHeight}\n          width={audioWidth}\n          audioEle={audioElement}\n          capColor={\"red\"}\n          capHeight={1}\n          meterWidth={2}\n          meterCount={(meters + 1) * 32}\n          meterColor={[\n            { stop: 0, color: \"#f00\" },\n            { stop: 0.3, color: \"#0CD7FD\" },\n            { stop: 1, color: \"red\" },\n          ]}\n          gap={1}\n        />\n      </div>\n      <button disabled={!station} className={styles.button} onClick={toggle}>\n        {isPlaying ? <Pause /> : <Play />}\n      </button>\n      <div>\n        <p className={styles.metadata}>\n          {typeof metadata === \"object\"\n            ? metadata.StreamTitle ||\n              (metadata.ARTIST\n                ? `${metadata.ARTIST} - ${metadata.TITLE}`\n                : metadata.TITLE) ||\n              metadata.VENDOR_STRING\n            : metadata}\n        </p>\n        {station?.link && (\n          <div className={styles.visitStation}>\n            {VISIT_STATION}\n            <a\n              className={styles.link}\n              href={station.link}\n              target=\"_blank\"\n              rel=\"noopener noreferrer\"\n            >\n              {station.name}\n            </a>\n          </div>\n        )}\n      </div>\n    </div>\n  );\n};\n\nexport default Player;\n","import React from \"react\";\nimport styles from \"./StationSelector.module.css\";\n\nconst Station = ({ id, station, changeStation }) => (\n  <div className={styles.station}>\n    <input\n      type=\"radio\"\n      className={styles.stationRadio}\n      id={id}\n      name=\"stations\"\n      onChange={() => changeStation(station)}\n    ></input>\n    <label className={styles.stationLabel} htmlFor={id}>\n      <div className={styles.stationName}>{station.name}</div>\n      <div className={styles.codecInfo}>\n        {station.codec} | {station.metadataTypes.join(\", \")}\n      </div>\n      <div className={styles.stationDescription}>{station.description}</div>\n    </label>\n  </div>\n);\n\nconst StationSelector = (props) =>\n  props.stations.map((station, idx) => (\n    <Station\n      key={idx}\n      station={station}\n      id={idx}\n      changeStation={props.changeStation}\n    />\n  ));\n\nexport default StationSelector;\n","import React from \"react\";\nimport styles from \"./About.module.css\";\n\nconst About = () => (\n  <div className={styles.about}>\n    <a\n      className={styles.mainLink}\n      href=\"https://github.com/eshaz/icecast-metadata-js\"\n    >\n      <div>icecast-metadata-js</div>\n    </a>\n    <div className={styles.description}>\n      Javascript library that reads, parses, and queues real-time metadata from\n      an Icecast stream.\n    </div>\n    <div className={styles.headerLink}>\n      <a className={styles.headerLink} style={{ fontWeight: \"bold\" }} href=\"/\">\n        React Demo\n      </a>\n      &nbsp;&nbsp; | &nbsp;&nbsp;\n      <a\n        className={styles.headerLink}\n        href={`${process.env.PUBLIC_URL}/demo.html`}\n      >\n        HTML Demo\n      </a>\n      &nbsp;&nbsp; | &nbsp;&nbsp;\n      <a\n        className={styles.headerLink}\n        href={`${process.env.PUBLIC_URL}/bare-minimum-demo.html`}\n      >\n        <i>\"Bare Minimum\"</i> &nbsp;HTML Demo\n      </a>\n    </div>\n  </div>\n);\n\nexport default About;\n","import React, { useState } from \"react\";\nimport Player from \"./Player/Player\";\nimport StationSelector from \"./StationSelector/StationSelector\";\nimport stations from \"./stations.json\";\nimport styles from \"./App.module.css\";\nimport About from \"./About/About\";\n\nfunction App() {\n  const [station, setStation] = useState();\n\n  return (\n    <>\n      <header className={styles.header}>\n        <About />\n      </header>\n      <StationSelector stations={stations} changeStation={setStation} />\n      <footer className={styles.footer}>\n        <Player station={station}></Player>\n      </footer>\n    </>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === \"localhost\" ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === \"[::1]\" ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === \"production\" && \"serviceWorker\" in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener(\"load\", () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            \"This web app is being served cache-first by a service \" +\n              \"worker. To learn more, visit https://bit.ly/CRA-PWA\"\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then((registration) => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === \"installed\") {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                \"New content is available and will be used when all \" +\n                  \"tabs for this page are closed. See https://bit.ly/CRA-PWA.\"\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log(\"Content is cached for offline use.\");\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch((error) => {\n      console.error(\"Error during service worker registration:\", error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { \"Service-Worker\": \"script\" },\n  })\n    .then((response) => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get(\"content-type\");\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf(\"javascript\") === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then((registration) => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        \"No internet connection found. App is running in offline mode.\"\n      );\n    });\n}\n\nexport function unregister() {\n  if (\"serviceWorker\" in navigator) {\n    navigator.serviceWorker.ready\n      .then((registration) => {\n        registration.unregister();\n      })\n      .catch((error) => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport \"./index.css\";\nimport App from \"./App\";\nimport * as serviceWorker from \"./serviceWorker\";\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById(\"root\")\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}
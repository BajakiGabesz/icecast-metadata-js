{"version":3,"sources":["Player/Player.module.css","About/About.module.css","StationSelector/StationSelector.module.css","App.module.css","../../icecast-metadata-player/src/IcecastMetadataPlayer.js","Player/Player.jsx","StationSelector/StationSelector.jsx","About/About.jsx","../../icecast-metadata-player/src/global.js","../../icecast-metadata-player/src/EventTargetPolyfill.js","../../icecast-metadata-player/src/players/Player.js","../../icecast-metadata-player/src/players/HTML5Player.js","../../icecast-metadata-player/src/FrameQueue.js","../../icecast-metadata-player/src/players/MediaSourcePlayer.js","../../icecast-metadata-player/src/players/WebAudioPlayer.js","../../icecast-metadata-player/src/PlayerFactory.js","App.js","serviceWorker.js","index.js"],"names":["module","exports","EventClass","ICECAST_METADATA_JS_DEMO","Player","station","playing","toggle","metadata","title","StreamTitle","TITLE","document","className","styles","player","disabled","button","onClick","playPause","viewBox","fill","d","playerText","ARTIST","VENDOR_STRING","link","visitStation","href","target","rel","name","Station","id","changeStation","type","stationRadio","onChange","stationLabel","htmlFor","stationName","codecInfo","codec","metadataTypes","join","stationDescription","description","StationSelector","props","stations","map","idx","About","about","mainLink","headerLink","style","fontWeight","process","noOp","p","WeakMap","state","event","PLAY","LOAD","STREAM_START","STREAM","STREAM_END","METADATA","METADATA_ENQUEUE","CODEC_UPDATE","STOP","RETRY","RETRY_TIMEOUT","WARN","ERROR","endpoint","Symbol","audioElement","icyMetaInt","icyDetectionTimeout","enableLogging","retryDelayRate","retryDelayMin","retryDelayMax","retryTimeout","fireEvent","attachAudioElement","shouldRetry","logError","hasIcy","icecastMetadataQueue","abortController","SYNCED","SYNCING","NOT_SYNCED","EventTargetPolyfill","this","_listeners","listener","some","item","options","hasEventListener","push","index","findIndex","splice","evt","filter","forEach","once","call","removeEventListener","icecast","inputMimeType","instanceVariables","get","_icecast","_inputMimeType","_codec","_audioElement","_icecastMetadataQueue","_endpoint","removeAttribute","srcObject","window","MediaSource","src","URL","createObjectURL","MediaStream","loop","a","frames","addMetadata","metadataTimestamp","currentTime","mimeType","match","mime","codecChecker","mapping","matches","parseMimeType","checkCodecs","codecs","reduce","acc","result","groups","mimeMapping","Array","isArray","mimeCodecs","split","length","HTML5Player","crossOrigin","preload","reset","_frame","totalDuration","_metadataTimestampOffset","_audioLoadedTimestamp","performance","now","_metadataLoadedTimestamp","_firedPlay","addEventListener","play","Audio","canPlayType","FrameQueue","CACHE_DURATION","initSync","initQueue","_syncQueue","_alignIndex","_syncIndex","_queue","_queueDuration","crc32","duration","shift","frame","add","align_queues","syncQueue","sliceIndex","slice","toFixed","newFrames","MediaSourcePlayer","_syncState","_mediaSource","sourceBuffers","Math","max","timestampOffset","buffered","end","_frameQueue","_mediaSourcePromise","_prepareMediaSource","flatMap","codecFrames","sync","addAll","isTypeSupported","_createMediaSource","data","_appendSourceBuffer","wrapper","MSEAudioWrapper","Error","iterator","fragment","Promise","resolve","_sourceBufferRemoved","addSourceBuffer","mode","chunk","appendBuffer","_waitForSourceBuffer","BUFFER_INTERVAL","Date","remove","mpeg","aac","aacp","ogg","flac","opus","vorbis","WebAudioPlayer","_resetOggPageBuffer","_currentSample","_currentSampleOffset","_sampleRate","_startTime","_syncSuccessful","undefined","_audioContext","close","AudioContext","webkitAudioContext","_mediaStream","createMediaStreamDestination","stream","_opusDecoder","ready","free","OpusDecoder","onDecodeAll","decodedAudio","_onDecode","oggPages","oggPageData","oggPage","rawData","_addOggPageBuffer","_oggPageBufferLength","_getOggPageBuffer","decode","channelData","samplesDecoded","floor","audioBuffer","createBuffer","channel","getChannelData","set","source","createBufferSource","buffer","connect","start","_oggPageBuffer","Uint8Array","offset","buf","WebAssembly","PlayerFactory","preferredPlaybackMethod","_metadataTypes","_icyMetaInt","_icyDetectionTimeout","_hasIcy","_preferredPlaybackMethod","_playbackMethod","_player","_unprocessedFrames","_codecParser","_icecastReadableStream","fetchStream","then","res","readIcecastResponse","finally","fetch","method","headers","signal","ok","error","status","url","codecPromise","onCodec","CodecParser","onCodecUpdate","args","IcecastReadableStream","onMetadata","onStream","isAudioPlayer","onError","icecastPromise","startReading","_buildPlayer","mediasource","webaudio","html5","firstMethod","rest","Object","values","support","EventTarget","playbackMethod","playerFactory","playerResetPromise","events","playerState","onAudioPause","onAudioPlay","onAudioCanPlay","onAudioError","onAudioWaiting","resetPlayback","retryAttempt","retryTimeoutId","IcecastMetadataPlayer","includes","onPlay","onLoad","onStreamStart","onStreamEnd","onMetadataEnqueue","onStop","onRetry","onRetryTimeout","messages","console","warn","onWarn","IcecastMetadataQueue","onMetadataUpdate","clearTimeout","pause","purgeMetadataQueue","stop","audio","e","1","2","3","4","5","code","message","metadataQueue","_state","dispatchEvent","CustomEvent","AbortController","tryFetching","playStream","catch","abort","stack","delay","min","setTimeout","random","audioWaiting","detail","consoleFunction","callback","App","useState","setStation","setPlaying","setMetadata","setIcecast","analyzer","useRef","audioMotion","setAudioMotion","useCallback","detachAudioElement","meta","log","useEffect","AudioMotionAnalyzer","current","showScaleX","fftSize","gradient","showBgColor","barSpace","lumiBars","useLayoutEffect","resizeObserver","ResizeObserver","setCanvasSize","innerWidth","innerHeight","observe","disconnect","spectrum","ref","header","footer","Boolean","location","hostname","ReactDOM","render","StrictMode","getElementById","navigator","serviceWorker","registration","unregister"],"mappings":"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","file":"static/js/main.e1585595.chunk.js","sourcesContent":["// extracted by mini-css-extract-plugin\nmodule.exports = {\"visitStation\":\"Player_visitStation__2xKeH\",\"playerText\":\"Player_playerText__Cw7Rh\",\"metadata\":\"Player_metadata__3j7ae\",\"playPause\":\"Player_playPause__3bmnX\",\"player\":\"Player_player__1vYfQ\",\"stationRadio\":\"Player_stationRadio__10mpt\",\"button\":\"Player_button__297uW\",\"link\":\"Player_link__2k87w\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"about\":\"About_about__2v-0B\",\"headerLink\":\"About_headerLink__3aZVt\",\"mainLink\":\"About_mainLink__1aSaU\",\"subLink\":\"About_subLink__n5KCY\",\"description\":\"About_description__3WN3o\",\"disclaimer\":\"About_disclaimer__2gOk6\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"station\":\"StationSelector_station__3a44c\",\"stationRadio\":\"StationSelector_stationRadio__1FTGQ\",\"stationLabel\":\"StationSelector_stationLabel__1DbUR\",\"stationName\":\"StationSelector_stationName__1hB_K\",\"stationDescription\":\"StationSelector_stationDescription__36TBn\",\"codecInfo\":\"StationSelector_codecInfo__JZjFy\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"header\":\"App_header__3ZZ1n\",\"footer\":\"App_footer__29Fsv\",\"spectrum\":\"App_spectrum__MkN9s\"};","/**\n * @license\n * @see https://github.com/eshaz/icecast-metadata-js\n * @copyright 2021 Ethan Halsall\n *  This file is part of icecast-metadata-player.\n *\n *  icecast-metadata-player free software: you can redistribute it and/or modify\n *  it under the terms of the GNU Lesser General Public License as published by\n *  the Free Software Foundation, either version 3 of the License, or\n *  (at your option) any later version.\n *\n *  icecast-metadata-player distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU Lesser General Public License for more details.\n *\n *  You should have received a copy of the GNU Lesser General Public License\n *  along with this program.  If not, see <https://www.gnu.org/licenses/>\n */\n\nimport { IcecastMetadataQueue } from \"icecast-metadata-js\";\nimport {\n  p,\n  noOp,\n  state,\n  event,\n  // options,\n  endpoint,\n  metadataTypes,\n  audioElement,\n  icyMetaInt,\n  icyDetectionTimeout,\n  enableLogging,\n  retryDelayMin,\n  retryDelayMax,\n  retryDelayRate,\n  retryTimeout,\n  // methods\n  fireEvent,\n  attachAudioElement,\n  shouldRetry,\n  logError,\n  // variables\n  hasIcy,\n  icecastMetadataQueue,\n  abortController,\n} from \"./global.js\";\n\nimport EventTargetPolyfill from \"./EventTargetPolyfill.js\";\nimport PlayerFactory from \"./PlayerFactory.js\";\nimport MediaSourcePlayer from \"./players/MediaSourcePlayer.js\";\nimport HTML5Player from \"./players/HTML5Player.js\";\nimport WebAudioPlayer from \"./players/WebAudioPlayer.js\";\n\nlet EventClass;\n\ntry {\n  new EventTarget();\n  EventClass = EventTarget;\n} catch {\n  EventClass = EventTargetPolyfill;\n}\n\nconst playbackMethod = Symbol();\nconst playerFactory = Symbol();\nconst playerResetPromise = Symbol();\nconst events = Symbol();\nconst playerState = Symbol();\n\nconst onAudioPause = Symbol();\nconst onAudioPlay = Symbol();\nconst onAudioCanPlay = Symbol();\nconst onAudioError = Symbol();\nconst onAudioWaiting = Symbol();\n\nconst resetPlayback = Symbol();\nconst retryAttempt = Symbol();\nconst retryTimeoutId = Symbol();\n\nexport default class IcecastMetadataPlayer extends EventClass {\n  /**\n   * @constructor\n   * @param {string} endpoint Endpoint of the Icecast compatible stream\n   * @param {object} options Options object\n   * @param {HTMLAudioElement} options.audioElement Audio element to play the stream\n   * @param {Array} options.metadataTypes Array of metadata types to parse\n   * @param {number} options.icyMetaInt ICY metadata interval\n   * @param {number} options.icyDetectionTimeout ICY metadata detection timeout\n   * @param {number} options.retryTimeout Number of seconds to wait before giving up on retries\n   * @param {number} options.retryDelayRate Percentage of seconds to increment after each retry (how quickly to increase the back-off)\n   * @param {number} options.retryDelayMin Minimum number of seconds between retries (start of the exponential back-off curve)\n   * @param {number} options.retryDelayMax Maximum number of seconds between retries (end of the exponential back-off curve)\n   * @param {number} options.enableLogging Set to `true` to enable warning and error logging to the console\n   * @param {string} options.playbackMethod Sets the preferred playback method (mediasource (default), html5, webaudio)\n   *\n   * @callback options.onMetadata Called with metadata when synchronized with the audio\n   * @callback options.onMetadataEnqueue Called with metadata when discovered on the response\n   * @callback options.onError Called with message(s) when a fallback or error condition is met\n   * @callback options.onWarn Called with message(s) when a warning condition is met\n   * @callback options.onPlay Called when the audio element begins playing\n   * @callback options.onLoad Called when stream request is started\n   * @callback options.onStreamStart Called when stream requests begins to return data\n   * @callback options.onStream Called when stream data is sent to the audio element\n   * @callback options.onStreamEnd Called when the stream request completes\n   * @callback options.onStop Called when the stream is completely stopped and all cleanup operations are complete\n   * @callback options.onRetry Called when a connection retry is attempted\n   * @callback options.onRetryTimeout Called when when connections attempts have timed out\n   * @callback options.onCodecUpdate Called when the audio codec information has changed\n   */\n  constructor(url, options = {}) {\n    super();\n\n    p.set(this, {\n      // options\n      [endpoint]: url,\n      [audioElement]: options.audioElement || new Audio(),\n      [icyMetaInt]: options.icyMetaInt,\n      [icyDetectionTimeout]: options.icyDetectionTimeout,\n      [metadataTypes]: options.metadataTypes || [\"icy\"],\n      [hasIcy]: (options.metadataTypes || [\"icy\"]).includes(\"icy\"),\n      [enableLogging]: options.enableLogging || false,\n      [retryDelayRate]: (options.retryDelayRate || 0.1) + 1,\n      [retryDelayMin]: (options.retryDelayMin || 0.5) * 1000,\n      [retryDelayMax]: (options.retryDelayMax || 2) * 1000,\n      [retryTimeout]: (options.retryTimeout || 30) * 1000,\n      [playbackMethod]: options.playbackMethod,\n      // callbacks\n      [events]: {\n        [event.PLAY]: options.onPlay || noOp,\n        [event.LOAD]: options.onLoad || noOp,\n        [event.STREAM_START]: options.onStreamStart || noOp,\n        [event.STREAM]: options.onStream || noOp,\n        [event.STREAM_END]: options.onStreamEnd || noOp,\n        [event.METADATA]: options.onMetadata || noOp,\n        [event.METADATA_ENQUEUE]: options.onMetadataEnqueue || noOp,\n        [event.CODEC_UPDATE]: options.onCodecUpdate || noOp,\n        [event.STOP]: options.onStop || noOp,\n        [event.RETRY]: options.onRetry || noOp,\n        [event.RETRY_TIMEOUT]: options.onRetryTimeout || noOp,\n        [event.WARN]: (...messages) => {\n          this[logError](console.warn, options.onWarn, messages);\n        },\n        [event.ERROR]: (...messages) => {\n          this[logError](console.error, options.onError, messages);\n        },\n      },\n      // variables\n      [icecastMetadataQueue]: new IcecastMetadataQueue({\n        onMetadataUpdate: (...args) => this[fireEvent](event.METADATA, ...args),\n        onMetadataEnqueue: (...args) =>\n          this[fireEvent](event.METADATA_ENQUEUE, ...args),\n      }),\n      [resetPlayback]: () => {\n        clearTimeout(p.get(this)[retryTimeoutId]);\n        this.removeEventListener(\n          event.STREAM_START,\n          p.get(this)[resetPlayback]\n        );\n        p.get(this)[audioElement].removeEventListener(\n          \"waiting\",\n          p.get(this)[onAudioWaiting]\n        );\n\n        if (this.state !== state.RETRYING) {\n          p.get(this)[audioElement].pause();\n          p.get(this)[icecastMetadataQueue].purgeMetadataQueue();\n          p.get(this)[playerResetPromise] = p\n            .get(this)\n            [playerFactory].player.reset();\n        }\n      },\n      // audio element event handlers\n      [onAudioPlay]: () => {\n        this.play();\n      },\n      [onAudioPause]: () => {\n        this.stop();\n      },\n      [onAudioCanPlay]: () => {\n        const audio = p.get(this)[audioElement];\n\n        if (\n          this.state === state.LOADING ||\n          (!audio.loop &&\n            this.state !== state.STOPPING &&\n            this.state !== state.STOPPED)\n        ) {\n          audio.play();\n          this[playerState] = state.PLAYING;\n        }\n      },\n      [onAudioError]: (e) => {\n        const errors = {\n          1: \"MEDIA_ERR_ABORTED The fetching of the associated resource was aborted by the user's request.\",\n          2: \"MEDIA_ERR_NETWORK Some kind of network error occurred which prevented the media from being successfully fetched, despite having previously been available.\",\n          3: \"MEDIA_ERR_DECODE Despite having previously been determined to be usable, an error occurred while trying to decode the media resource, resulting in an error.\",\n          4: \"MEDIA_ERR_SRC_NOT_SUPPORTED The associated resource or media provider object (such as a MediaStream) has been found to be unsuitable.\",\n          5: \"MEDIA_ERR_ENCRYPTED\",\n        };\n\n        if (this.state !== state.RETRYING) {\n          this[fireEvent](\n            event.ERROR,\n            \"The audio element encountered an error\",\n            errors[e.target.error.code] || `Code: ${e.target.error.code}`,\n            `Message: ${e.target.error.message}`\n          );\n\n          this.stop();\n        } else {\n          p.get(this)[resetPlayback]();\n        }\n      },\n    });\n\n    this[attachAudioElement]();\n    this[playerState] = state.STOPPED;\n\n    p.get(this)[playerFactory] = new PlayerFactory(\n      this,\n      p.get(this)[playbackMethod]\n    );\n  }\n\n  /**\n   * @description Checks for MediaSource and HTML5 support for a given codec\n   * @param {string} type Codec / mime-type to check\n   * @returns {mediasource: string, html5: string} Object indicating if the codec is supported by MediaSource or HTML5 audio\n   */\n  static canPlayType(type) {\n    return {\n      mediasource: MediaSourcePlayer.canPlayType(type),\n      html5: HTML5Player.canPlayType(type),\n      webaudio: WebAudioPlayer.canPlayType(type),\n    };\n  }\n\n  /**\n   * @returns {HTMLAudioElement} The audio element associated with this instance\n   */\n  get audioElement() {\n    return p.get(this)[audioElement];\n  }\n\n  /**\n   * @returns {number} The ICY metadata interval in number of bytes for this instance\n   */\n  get icyMetaInt() {\n    return p.get(this)[playerFactory].icyMetaInt;\n  }\n\n  /**\n   * @returns {Array<Metadata>} Array of enqueued metadata objects in FILO order\n   */\n  get metadataQueue() {\n    return p.get(this)[icecastMetadataQueue].metadataQueue;\n  }\n\n  /**\n   * @returns {string} The current state (\"loading\", \"playing\", \"stopping\", \"stopped\", \"retrying\")\n   */\n  get state() {\n    return p.get(this)[playerState];\n  }\n\n  /**\n   * @returns {string} The playback method (\"mediasource\", \"webaudio\", \"html5\")\n   */\n  get playbackMethod() {\n    return p.get(this)[playerFactory].playbackMethod;\n  }\n\n  set [playerState](_state) {\n    this.dispatchEvent(new CustomEvent(_state));\n    p.get(this)[playerState] = _state;\n  }\n\n  [attachAudioElement]() {\n    // audio events\n    const audio = p.get(this)[audioElement];\n    audio.addEventListener(\"pause\", p.get(this)[onAudioPause]);\n    audio.addEventListener(\"play\", p.get(this)[onAudioPlay]);\n    audio.addEventListener(\"canplay\", p.get(this)[onAudioCanPlay]);\n    audio.addEventListener(\"error\", p.get(this)[onAudioError]);\n  }\n\n  /**\n   * @description Remove event listeners from the audio element and this instance and stops playback\n   */\n  async detachAudioElement() {\n    const audio = p.get(this)[audioElement];\n    audio.removeEventListener(\"pause\", p.get(this)[onAudioPause]);\n    audio.removeEventListener(\"play\", p.get(this)[onAudioPlay]);\n    audio.removeEventListener(\"canplay\", p.get(this)[onAudioCanPlay]);\n    audio.removeEventListener(\"error\", p.get(this)[onAudioError]);\n\n    await this.stop();\n  }\n\n  /**\n   * @description Plays the Icecast stream\n   * @async Resolves when the audio element is playing\n   */\n  async play() {\n    if (this.state === state.STOPPED) {\n      p.get(this)[abortController] = new AbortController();\n      this[playerState] = state.LOADING;\n      this[fireEvent](event.LOAD);\n\n      // prettier-ignore\n      const tryFetching = async () =>\n        p.get(this)[playerFactory].playStream()\n          .catch(async (e) => {\n            if (e.name !== \"AbortError\") {\n              if (await this[shouldRetry](e)) {\n                this[fireEvent](event.RETRY);\n                return tryFetching();\n              }\n\n              p.get(this)[abortController].abort(); // stop fetch if is wasn't aborted\n\n              if (\n                p.get(this)[playerState] !== state.STOPPING &&\n                p.get(this)[playerState] !== state.STOPPED\n              ) {\n                this[fireEvent](\n                  event.ERROR,\n                  e.message.match(/network|fetch|offline|codec/i) ? e : e.stack\n                );\n              }\n            }\n          });\n\n      tryFetching().finally(() => {\n        p.get(this)[resetPlayback]();\n\n        this[fireEvent](event.STOP);\n        this[playerState] = state.STOPPED;\n      });\n\n      await new Promise((resolve) => {\n        this.addEventListener(event.PLAY, resolve, { once: true });\n      });\n    }\n  }\n\n  /**\n   * @description Stops playing the Icecast stream\n   * @async Resolves the icecast stream has stopped\n   */\n  async stop() {\n    if (this.state !== state.STOPPED && this.state !== state.STOPPING) {\n      this[playerState] = state.STOPPING;\n      p.get(this)[abortController].abort();\n\n      await new Promise((resolve) => {\n        this.addEventListener(event.STOP, resolve, { once: true });\n      });\n    }\n  }\n\n  async [shouldRetry](error) {\n    if (p.get(this)[retryTimeout] === 0) return false;\n\n    if (p.get(this)[playerState] === state.RETRYING) {\n      // wait for retry interval\n      await new Promise((resolve) => {\n        this.addEventListener(state.STOPPING, resolve, { once: true });\n\n        const delay = Math.min(\n          p.get(this)[retryDelayMin] *\n            p.get(this)[retryDelayRate] ** p.get(this)[retryAttempt]++,\n          p.get(this)[retryDelayMax]\n        ); // exponential backoff\n\n        setTimeout(() => {\n          this.removeEventListener(state.STOPPING, resolve);\n          resolve();\n        }, delay + delay * 0.3 * Math.random()); // jitter\n      });\n\n      // ensure the retry hasn't been cancelled while waiting\n      return p.get(this)[playerState] === state.RETRYING;\n    }\n\n    if (\n      p.get(this)[playerState] !== state.STOPPING &&\n      p.get(this)[playerState] !== state.STOPPED &&\n      (error.message.match(/network|fetch|offline|Error in body stream/i) ||\n        error.name === \"HTTP Response Error\")\n    ) {\n      this[fireEvent](event.ERROR, error);\n      this[playerState] = state.RETRYING;\n      this.addEventListener(event.STREAM_START, p.get(this)[resetPlayback], {\n        once: true,\n      });\n\n      if (p.get(this)[hasIcy]) {\n        this[fireEvent](\n          event.WARN,\n          \"This stream was requested with ICY metadata.\",\n          'If there is a CORS preflight failure, try removing \"icy\" from the metadataTypes option.',\n          \"See https://github.com/eshaz/icecast-metadata-js#cors for more details.\"\n        );\n      }\n\n      const audioWaiting = new Promise((resolve) => {\n        p.get(this)[onAudioWaiting] = resolve;\n        p.get(this)[audioElement].addEventListener(\n          \"waiting\",\n          p.get(this)[onAudioWaiting],\n          {\n            once: true,\n          }\n        );\n      });\n\n      // wait for whichever is longer, audio element waiting or retry timeout\n      p.get(this)[retryTimeoutId] = setTimeout(() => {\n        audioWaiting.then(() => {\n          if (p.get(this)[playerState] === state.RETRYING) {\n            this[fireEvent](event.RETRY_TIMEOUT);\n            this.stop();\n          }\n        });\n      }, p.get(this)[retryTimeout]);\n\n      p.get(this)[retryAttempt] = 0;\n      return true;\n    }\n\n    return false;\n  }\n\n  [fireEvent](event, ...args) {\n    this.dispatchEvent(new CustomEvent(event, { detail: args }));\n    p.get(this)[events][event](...args);\n  }\n\n  [logError](consoleFunction, callback, messages) {\n    if (p.get(this)[enableLogging]) {\n      consoleFunction(\n        \"icecast-metadata-js\",\n        messages.reduce((acc, message) => acc + \"\\n  \" + message, \"\")\n      );\n    }\n    if (callback) callback(...messages);\n  }\n}\n","import React from \"react\";\nimport styles from \"./Player.module.css\";\n\nconst VISIT_STATION = \"Visit this station at \";\nconst ICECAST_METADATA_JS_DEMO = \"Icecast Metadata JS Demo\";\n\nconst Player = ({ station, playing, toggle, metadata }) => {\n  // update metadata in title\n  const title = metadata.StreamTitle || metadata.TITLE;\n  document.title = title\n    ? `${title} | ${ICECAST_METADATA_JS_DEMO}`\n    : ICECAST_METADATA_JS_DEMO;\n\n  return (\n    <div className={styles.player}>\n      <button disabled={!station} className={styles.button} onClick={toggle}>\n        {playing ? (\n          <svg className={styles.playPause} viewBox=\"0 0 450 525\">\n            <path\n              fill=\"#999\"\n              d=\"M144 479H48c-26.5 0-48-21.5-48-48V79c0-26.5 21.5-48 48-48h96c26.5 0 48 21.5 48 48v352c0 26.5-21.5 48-48 48zm304-48V79c0-26.5-21.5-48-48-48h-96c-26.5 0-48 21.5-48 48v352c0 26.5 21.5 48 48 48h96c26.5 0 48-21.5 48-48z\"\n            />\n          </svg>\n        ) : (\n          <svg className={styles.playPause} viewBox=\"0 0 450 525\">\n            <path\n              fill=\"#999\"\n              d=\"M424.4 214.7L72.4 6.6C43.8-10.3 0 6.1 0 47.9V464c0 37.5 40.7 60.1 72.4 41.3l352-208c31.4-18.5 31.5-64.1 0-82.6z\"\n            />\n          </svg>\n        )}\n      </button>\n      <div className={styles.playerText}>\n        <div className={styles.metadata}>\n          {typeof metadata === \"object\"\n            ? metadata.StreamTitle ||\n              (metadata.ARTIST\n                ? `${metadata.ARTIST} - ${metadata.TITLE}`\n                : metadata.TITLE) ||\n              metadata.VENDOR_STRING\n            : metadata}\n        </div>\n        {station?.link && (\n          <div className={styles.visitStation}>\n            {VISIT_STATION}\n            <a\n              className={styles.link}\n              href={station.link}\n              target=\"_blank\"\n              rel=\"noopener noreferrer\"\n            >\n              {station.name}\n            </a>\n          </div>\n        )}\n      </div>\n    </div>\n  );\n};\n\nexport default Player;\n","import React from \"react\";\nimport styles from \"./StationSelector.module.css\";\n\nconst Station = ({ id, station, changeStation }) => (\n  <div className={styles.station}>\n    <input\n      type=\"radio\"\n      className={styles.stationRadio}\n      id={id}\n      name=\"stations\"\n      onChange={() => changeStation(station)}\n    ></input>\n    <label className={styles.stationLabel} htmlFor={id}>\n      <div className={styles.stationName}>{station.name}</div>\n      <div className={styles.codecInfo}>\n        {station.codec} | {station.metadataTypes.join(\", \")}\n      </div>\n      <div className={styles.stationDescription}>{station.description}</div>\n    </label>\n  </div>\n);\n\nconst StationSelector = (props) =>\n  props.stations.map((station, idx) => (\n    <Station\n      key={idx}\n      station={station}\n      id={idx}\n      changeStation={props.changeStation}\n    />\n  ));\n\nexport default StationSelector;\n","import React from \"react\";\nimport styles from \"./About.module.css\";\n\nconst About = () => (\n  <div className={styles.about}>\n    <a\n      className={styles.mainLink}\n      href=\"https://github.com/eshaz/icecast-metadata-js\"\n    >\n      <div>icecast-metadata-js</div>\n    </a>\n    <div className={styles.description}>\n      Javascript library that reads, parses, and queues real-time metadata from\n      an Icecast stream.\n    </div>\n    <div className={styles.headerLink}>\n      <a className={styles.headerLink} style={{ fontWeight: \"bold\" }} href=\"/\">\n        React Demo\n      </a>\n      &nbsp;&nbsp; | &nbsp;&nbsp;\n      <a\n        className={styles.headerLink}\n        href={`${process.env.PUBLIC_URL}/demo.html`}\n      >\n        HTML Demo\n      </a>\n      &nbsp;&nbsp; | &nbsp;&nbsp;\n      <a\n        className={styles.headerLink}\n        href={`${process.env.PUBLIC_URL}/bare-minimum-demo.html`}\n      >\n        <i>\"Bare Minimum\"</i> &nbsp;HTML Demo\n      </a>\n    </div>\n  </div>\n);\n\nexport default About;\n","export const noOp = () => {};\nexport const p = new WeakMap();\n\nexport const state = {\n  LOADING: \"loading\",\n  PLAYING: \"playing\",\n  STOPPING: \"stopping\",\n  STOPPED: \"stopped\",\n  RETRYING: \"retrying\",\n};\n\nexport const event = {\n  PLAY: \"play\",\n  LOAD: \"load\",\n  STREAM_START: \"streamstart\",\n  STREAM: \"stream\",\n  STREAM_END: \"streamend\",\n  METADATA: \"metadata\",\n  METADATA_ENQUEUE: \"metadataenqueue\",\n  CODEC_UPDATE: \"codecupdate\",\n  STOP: \"stop\",\n  RETRY: \"retry\",\n  RETRY_TIMEOUT: \"retrytimeout\",\n  WARN: \"warn\",\n  ERROR: \"error\",\n};\n\n// options\nexport const endpoint = Symbol();\nexport const metadataTypes = Symbol();\nexport const audioElement = Symbol();\nexport const icyMetaInt = Symbol();\nexport const icyDetectionTimeout = Symbol();\nexport const enableLogging = Symbol();\nexport const retryDelayRate = Symbol();\nexport const retryDelayMin = Symbol();\nexport const retryDelayMax = Symbol();\nexport const retryTimeout = Symbol();\n\n// methods\nexport const fireEvent = Symbol();\nexport const attachAudioElement = Symbol();\nexport const shouldRetry = Symbol();\nexport const logError = Symbol();\n\n// variables\nexport const hasIcy = Symbol();\nexport const icecastMetadataQueue = Symbol();\nexport const abortController = Symbol();\n\n// sync state\nexport const SYNCED = Symbol();\nexport const SYNCING = Symbol();\nexport const NOT_SYNCED = Symbol();\n","// support for Safari 13\n// https://stackoverflow.com/a/58209729/14911733\n\nexport default class EventTargetPolyfill {\n  constructor() {\n    this._listeners = [];\n  }\n\n  hasEventListener(type, listener) {\n    return this._listeners.some(\n      (item) => item.type === type && item.listener === listener\n    );\n  }\n\n  addEventListener(type, listener, options = {}) {\n    if (!this.hasEventListener(type, listener)) {\n      this._listeners.push({ type, listener, options });\n    }\n    // console.log(`${this}-listeners:`,this._listeners);\n    return this;\n  }\n\n  removeEventListener(type, listener) {\n    const index = this._listeners.findIndex(\n      (item) => item.type === type && item.listener === listener\n    );\n    if (index >= 0) this._listeners.splice(index, 1);\n    return this;\n  }\n\n  removeEventListeners() {\n    this._listeners = [];\n    return this;\n  }\n\n  dispatchEvent(evt) {\n    this._listeners\n      .filter((item) => item.type === evt.type)\n      .forEach((item) => {\n        const {\n          type,\n          listener,\n          options: { once },\n        } = item;\n        listener.call(this, evt);\n        if (once === true) this.removeEventListener(type, listener);\n      });\n    return this;\n  }\n}\n","import { p, audioElement, icecastMetadataQueue, endpoint } from \"../global.js\";\n\nexport default class Player {\n  constructor(icecast, inputMimeType, codec) {\n    const instanceVariables = p.get(icecast);\n\n    this._icecast = icecast;\n    this._inputMimeType = inputMimeType;\n    this._codec = codec;\n\n    this._audioElement = instanceVariables[audioElement];\n    this._icecastMetadataQueue = instanceVariables[icecastMetadataQueue];\n    this._endpoint = instanceVariables[endpoint];\n\n    // set the audio element an empty source to enable the play button\n    try {\n      this._audioElement.removeAttribute(\"src\");\n      this._audioElement.srcObject = null;\n\n      if (window.MediaSource) {\n        this._audioElement.src = URL.createObjectURL(new MediaSource());\n      } else {\n        this._audioElement.srcObject = new MediaStream();\n      }\n    } catch {\n      // mp3 32kbs silence\n      this._audioElement.src =\n        \"data:audio/mpeg;base64,//sQxAAABFgC/SCEYACCgB9AAAAAppppVCAHBAEIgBByw9WD5+J8ufwxiDED\" +\n        \"sMfE+D4fwG/RUGCx6VO4awVxV3qDtQNPiXKnZUNSwKuUDR6IgaeoGg7Fg6pMQU1FMy4xMDCqqqqqqqr/+xL\" +\n        \"EB4PAAAGkAAAAIAAANIAAAASqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq\" +\n        \"qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqo=\";\n\n      this._audioElement.loop = true;\n    }\n  }\n\n  static parseMimeType(mimeType) {\n    return mimeType.match(\n      /^(?:application\\/|audio\\/|)(?<mime>[a-zA-Z]+)(?:$|;[ ]*codecs=(?:\\'|\\\")(?<codecs>[a-zA-Z,]+)(?:\\'|\\\"))/\n    );\n  }\n\n  static canPlayType(codecChecker, mimeType, mapping) {\n    const matches = Player.parseMimeType(mimeType);\n\n    const checkCodecs = (codecs) =>\n      codecs.reduce((acc, codec) => {\n        if (acc === \"\") return \"\";\n\n        const result = codecChecker(codec);\n\n        if (!result) return \"\";\n        if (result === \"maybe\" || acc === \"maybe\") return \"maybe\";\n        if (result === true || result === \"probably\") return \"probably\";\n      }, null);\n\n    if (matches) {\n      const { mime, codecs } = matches.groups;\n\n      const mimeMapping = mapping && mapping[mime];\n\n      // mapping is a raw codec\n      if (!mimeMapping || Array.isArray(mimeMapping)) {\n        return (\n          checkCodecs(mimeMapping || [mimeType]) || // check with the codec\n          checkCodecs([`audio/${mime}`]) // check as a raw mimetype\n        );\n      }\n\n      // mapping ia a container\n      if (typeof mimeMapping === \"object\") {\n        if (codecs) {\n          const mimeCodecs = codecs.split(\",\");\n\n          // multiple codecs are not supported\n          if (mimeCodecs.length > 1) return \"\";\n          if (!mimeMapping[mimeCodecs[0]]) return \"\";\n\n          return checkCodecs(mimeMapping[mimeCodecs[0]]);\n        }\n        // container exists in list but no codecs were specified\n        return \"maybe\";\n      }\n    }\n\n    // codec not in the list\n    return \"\";\n  }\n\n  /**\n   * @abstract\n   */\n  get isAudioPlayer() {\n    return false;\n  }\n\n  /**\n   * @interface\n   */\n  get metadataTimestamp() {\n    return 0;\n  }\n\n  /**\n   * @interface\n   */\n  get currentTime() {\n    return 0;\n  }\n\n  /**\n   * @interface\n   */\n  async reset() {}\n\n  /**\n   * @abstract\n   */\n  onStream(frames) {\n    return frames;\n  }\n\n  /**\n   * @abstract\n   */\n  onMetadata(metadata) {\n    this._icecastMetadataQueue.addMetadata(\n      metadata,\n      this.metadataTimestamp,\n      this.currentTime\n    );\n  }\n}\n","import { state, event, fireEvent } from \"../global.js\";\nimport Player from \"./Player.js\";\n\nexport default class HTML5Player extends Player {\n  constructor(icecast) {\n    super(icecast);\n\n    this._audioElement.crossOrigin = \"anonymous\";\n    this._audioElement.loop = false;\n    this._audioElement.preload = \"none\";\n\n    this.reset();\n  }\n\n  static canPlayType(mimeType) {\n    return super.canPlayType((type) => new Audio().canPlayType(type), mimeType);\n  }\n\n  static get name() {\n    return \"html5\";\n  }\n\n  get isAudioPlayer() {\n    return true;\n  }\n\n  get metadataTimestamp() {\n    return this._frame\n      ? (this._frame.totalDuration + this._metadataTimestampOffset) / 1000\n      : 0;\n  }\n\n  get currentTime() {\n    return (\n      this._audioLoadedTimestamp &&\n      (performance.now() - this._audioLoadedTimestamp) / 1000\n    );\n  }\n\n  async reset() {\n    this._frame = null;\n    this._metadataLoadedTimestamp = performance.now();\n    this._audioLoadedTimestamp = 0;\n    this._metadataTimestampOffset = 0;\n    this._firedPlay = false;\n\n    this._audioElement.removeAttribute(\"src\");\n    this._audioElement.src = this._endpoint;\n\n    if (\n      this._icecast.state !== state.STOPPING &&\n      this._icecast.state !== state.STOPPED\n    ) {\n      this._audioElement.addEventListener(\n        \"playing\",\n        () => {\n          this._audioLoadedTimestamp = performance.now();\n          this._metadataTimestampOffset =\n            performance.now() - this._metadataLoadedTimestamp;\n        },\n        { once: true }\n      );\n\n      this._audioElement.play();\n\n      if (!this._firedPlay) {\n        this._icecast[fireEvent](event.PLAY);\n        this._firedPlay = true;\n      }\n    }\n  }\n\n  onStream(frames) {\n    this._frame = frames[frames.length - 1] || this._frame;\n  }\n}\n","import { event, fireEvent } from \"./global.js\";\n\nexport default class FrameQueue {\n  constructor(icecast) {\n    this.CACHE_DURATION = 300000; // milliseconds of burst on connect data\n\n    this._icecast = icecast;\n\n    this.initSync();\n    this.initQueue();\n  }\n\n  initSync() {\n    this._syncQueue = [];\n    this._alignIndex = 0;\n    this._syncIndex = 0;\n  }\n\n  initQueue() {\n    this._queue = [];\n    this._queueDuration = 0;\n  }\n\n  add({ crc32, duration }) {\n    this._queue.push({ crc32, duration });\n    this._queueDuration += duration;\n\n    if (this._queueDuration >= this.CACHE_DURATION) {\n      const { duration } = this._queue.shift();\n      this._queueDuration -= duration;\n    }\n  }\n\n  addAll(frames) {\n    frames.forEach((frame) => this.add(frame));\n  }\n\n  /*\n  Aligns the queue with a new incoming data by aligning the crc32 hashes \n  and then returning only the frames that do not existing on the queue.\n  \n                   old data | common data  | new data\n  (old connection) ------------------------|\n  (new connection)          |------------------>\n                             ^^^^^^^^^^^^^^ ^^^^\n                              (sync)         (frames to return)\n  */\n\n  /**\n   *\n   * @param {Array<CodecFrame|OggPage>} frames\n   * @returns Array with frames as first element, boolean indicating if the sync was successful as the second element\n   */\n  sync(frames) {\n    this._syncQueue.push(...frames);\n\n    // find the index of the element in the queue that aligns with the sync queue\n    align_queues: while (this._alignIndex < this._queue.length) {\n      while (\n        this._syncIndex < this._syncQueue.length &&\n        this._alignIndex + this._syncIndex < this._queue.length\n      ) {\n        if (\n          this._syncQueue[this._syncIndex].crc32 !==\n          this._queue[this._alignIndex + this._syncIndex].crc32 // failed to match\n        ) {\n          this._syncIndex = 0; // reset sync queue index and start over\n          this._alignIndex++;\n          continue align_queues;\n        }\n        this._syncIndex++;\n      }\n      break; // full match, queues are aligned\n    }\n\n    // no matching data (not synced)\n    if (this._alignIndex === this._queue.length) {\n      // prettier-ignore\n      this._icecast[fireEvent](\n        event.WARN,\n        \"Reconnected successfully after retry event.\",\n        \"Found no overlapping frames from previous request.\",\n        \"Unable to sync old and new request.\"\n      );\n\n      const syncQueue = this._syncQueue;\n      this.initSync();\n      this.initQueue(); // clear queue since there is a gap in data\n      return [syncQueue, false];\n    }\n\n    const sliceIndex = this._queue.length - this._alignIndex;\n\n    // new frames (synced)\n    if (this._syncQueue.length > sliceIndex) {\n      // prettier-ignore\n      this._icecast[fireEvent](\n          event.WARN,\n          \"Reconnected successfully after retry event.\",\n          `Found ${sliceIndex} frames (${(this._queue\n            .slice(this._alignIndex)\n            .reduce((acc, { duration }) => acc + duration, 0) / 1000).toFixed(3)} seconds) of overlapping audio data in new request.`,\n          \"Synchronized old and new request.\"\n        );\n\n      const newFrames = this._syncQueue.slice(sliceIndex);\n      this.initSync();\n      return [newFrames, true];\n    }\n\n    // no new frames yet\n    return [[], false];\n  }\n}\n","import MSEAudioWrapper from \"mse-audio-wrapper\";\n\nimport {\n  state,\n  event,\n  fireEvent,\n  SYNCED,\n  SYNCING,\n  NOT_SYNCED,\n} from \"../global.js\";\nimport Player from \"./Player.js\";\nimport FrameQueue from \"../FrameQueue.js\";\n\nconst BUFFER = 10; // seconds of audio to store in SourceBuffer\nconst BUFFER_INTERVAL = 10; // seconds before removing from SourceBuffer\n\nexport default class MediaSourcePlayer extends Player {\n  constructor(icecast, inputMimeType, codec) {\n    super(icecast, inputMimeType, codec);\n\n    this.reset();\n\n    this._icecast.addEventListener(event.RETRY, () => {\n      this._syncState = NOT_SYNCED;\n    });\n  }\n\n  static canPlayType(mimeType) {\n    const mapping = {\n      mpeg: ['audio/mp4;codecs=\"mp3\"'],\n      aac: ['audio/mp4;codecs=\"mp4a.40.2\"'],\n      aacp: ['audio/mp4;codecs=\"mp4a.40.2\"'],\n      ogg: {\n        flac: ['audio/mp4;codecs=\"flac\"'],\n        opus: ['audio/mp4;codecs=\"opus\"', 'audio/webm;codecs=\"opus\"'],\n        vorbis: ['audio/webm;codecs=\"vorbis\"'],\n      },\n    };\n\n    try {\n      new MediaSource();\n    } catch {\n      return \"\";\n    }\n    if (MediaSource.isTypeSupported(mimeType)) return \"probably\";\n\n    return super.canPlayType(MediaSource.isTypeSupported, mimeType, mapping);\n  }\n\n  static get name() {\n    return \"mediasource\";\n  }\n\n  get isAudioPlayer() {\n    return true;\n  }\n\n  get metadataTimestamp() {\n    return (\n      (this._mediaSource &&\n        this._mediaSource.sourceBuffers.length &&\n        Math.max(\n          // work-around for WEBM reporting a negative timestampOffset\n          this._mediaSource.sourceBuffers[0].timestampOffset,\n          this._mediaSource.sourceBuffers[0].buffered.length\n            ? this._mediaSource.sourceBuffers[0].buffered.end(0)\n            : 0\n        )) ||\n      0\n    );\n  }\n\n  get currentTime() {\n    return this._audioElement.currentTime;\n  }\n\n  async reset() {\n    this._syncState = SYNCED;\n    this._frameQueue = new FrameQueue(this._icecast);\n    this._firedPlay = false;\n\n    this._mediaSourcePromise = this._prepareMediaSource(\n      this._inputMimeType,\n      this._codec\n    );\n\n    await this._mediaSourcePromise;\n  }\n\n  async onStream(frames) {\n    frames = frames.flatMap((frame) => frame.codecFrames || frame);\n\n    if (frames.length) {\n      switch (this._syncState) {\n        case NOT_SYNCED:\n          this._frameQueue.initSync();\n          this._syncState = SYNCING;\n        case SYNCING:\n          [frames] = this._frameQueue.sync(frames);\n          if (frames.length) this._syncState = SYNCED;\n      }\n\n      this._frameQueue.addAll(frames);\n\n      // when frames are present, we should already know the codec and have the mse audio mimetype determined\n      await (\n        await this._mediaSourcePromise\n      )(frames); // wait for the source buffer to be created\n    }\n  }\n\n  async _prepareMediaSource(inputMimeType, codec) {\n    if (MediaSource.isTypeSupported(inputMimeType)) {\n      // pass the audio directly to MSE\n\n      await this._createMediaSource(inputMimeType);\n\n      return async (frames) => {\n        for await (const { data } of frames) {\n          await this._appendSourceBuffer(data);\n        }\n      };\n    } else {\n      // wrap the audio into fragments before passing to MSE\n      const wrapper = new MSEAudioWrapper(inputMimeType, {\n        codec,\n      });\n\n      if (!MediaSource.isTypeSupported(wrapper.mimeType)) {\n        this._icecast[fireEvent](\n          event.ERROR,\n          `Media Source Extensions API in your browser does not support ${inputMimeType} or ${wrapper.mimeType}`,\n          \"See: https://caniuse.com/mediasource and https://developer.mozilla.org/en-US/docs/Web/API/Media_Source_Extensions_API\"\n        );\n        throw new Error(`Unsupported Media Source Codec ${wrapper.mimeType}`);\n      }\n\n      await this._createMediaSource(wrapper.mimeType);\n\n      return async (codecFrames) => {\n        for await (const fragment of wrapper.iterator(codecFrames)) {\n          await this._appendSourceBuffer(fragment);\n        }\n      };\n    }\n  }\n\n  async _createMediaSource(mimeType) {\n    await new Promise(async (resolve) => {\n      this._mediaSource = new MediaSource();\n      this._audioElement.loop = false;\n      this._audioElement.src = URL.createObjectURL(this._mediaSource);\n\n      this._mediaSource.addEventListener(\"sourceopen\", resolve, {\n        once: true,\n      });\n    });\n\n    this._sourceBufferRemoved = 0;\n    this._mediaSource.addSourceBuffer(mimeType).mode = \"sequence\";\n  }\n\n  async _waitForSourceBuffer() {\n    return new Promise((resolve) => {\n      this._mediaSource.sourceBuffers[0].addEventListener(\n        \"updateend\",\n        resolve,\n        {\n          once: true,\n        }\n      );\n    });\n  }\n\n  async _appendSourceBuffer(chunk) {\n    this._icecast[fireEvent](event.STREAM, chunk);\n\n    if (!this._mediaSource.sourceBuffers.length) {\n      this._icecast[fireEvent](\n        event.WARN,\n        \"Attempting to append audio, but MediaSource has not been or is no longer initialized\",\n        \"Please be sure that `detachAudioElement()` was called and awaited before reusing the element with a new IcecastMetadataPlayer instance\"\n      );\n    }\n\n    if (\n      this._icecast.state !== state.STOPPING &&\n      this._mediaSource.sourceBuffers.length\n    ) {\n      if (!this._firedPlay) {\n        this._icecast[fireEvent](event.PLAY);\n        this._firedPlay = true;\n      }\n\n      this._mediaSource.sourceBuffers[0].appendBuffer(chunk);\n      await this._waitForSourceBuffer();\n\n      if (\n        this._audioElement.currentTime > BUFFER &&\n        this._sourceBufferRemoved + BUFFER_INTERVAL * 1000 < Date.now()\n      ) {\n        this._sourceBufferRemoved = Date.now();\n        this._mediaSource.sourceBuffers[0].remove(\n          0,\n          this._audioElement.currentTime - BUFFER\n        );\n        await this._waitForSourceBuffer();\n      }\n    }\n  }\n}\n","import { OpusDecoder } from \"opus-decoder\";\n\nimport FrameQueue from \"../FrameQueue.js\";\nimport {\n  state,\n  event,\n  SYNCED,\n  SYNCING,\n  NOT_SYNCED,\n  fireEvent,\n} from \"../global.js\";\nimport Player from \"./Player.js\";\n\nexport default class WebAudioPlayer extends Player {\n  constructor(icecast, inputMimeType, codec) {\n    super(icecast, inputMimeType, codec);\n\n    this._icecast.addEventListener(event.RETRY, () => {\n      this._syncState = NOT_SYNCED;\n    });\n\n    this.reset();\n    this._resetOggPageBuffer();\n  }\n\n  static canPlayType(mimeType) {\n    const mapping = {\n      ogg: {\n        opus: ['audio/ogg;codecs=\"opus\"'],\n      },\n    };\n\n    if (!window.WebAssembly) return \"\";\n    if (!(window.AudioContext || window.webkitAudioContext)) return \"\";\n    if (!window.MediaStream) return \"\";\n\n    return super.canPlayType(\n      (codec) => codec === 'audio/ogg;codecs=\"opus\"',\n      mimeType,\n      mapping\n    );\n  }\n\n  static get name() {\n    return \"webaudio\";\n  }\n\n  get isAudioPlayer() {\n    return true;\n  }\n\n  get metadataTimestamp() {\n    return (this._currentSample + this._currentSampleOffset) / this._sampleRate;\n  }\n\n  get currentTime() {\n    return (Date.now() - this._startTime) / 1000 || 0;\n  }\n\n  async reset() {\n    this._syncState = SYNCED;\n    this._syncSuccessful = false;\n    this._frameQueue = new FrameQueue(this._icecast);\n\n    this._currentSample = 0;\n    this._currentSampleOffset = 0;\n    this._sampleRate = 48000; // opus\n    this._startTime = undefined;\n    this._firedPlay = false;\n\n    // reset audio context\n    if (this._audioContext) this._audioContext.close();\n\n    this._audioContext = new (window.AudioContext ||\n      window.webkitAudioContext)();\n\n    this._mediaStream = this._audioContext.createMediaStreamDestination();\n    this._audioElement.srcObject = this._mediaStream.stream;\n\n    // reset opus decoder\n    if (this._opusDecoder) {\n      await this._opusDecoder.ready;\n      this._opusDecoder.free();\n    }\n\n    this._opusDecoder = new OpusDecoder({\n      onDecodeAll: (decodedAudio) => {\n        this._onDecode(decodedAudio);\n      },\n    });\n  }\n\n  async onStream(oggPages) {\n    for await (const oggPage of oggPages) {\n      let oggPageData = oggPage.rawData;\n\n      if (oggPage.codecFrames.length === 0) {\n        // store any initialization pages\n        this._addOggPageBuffer(oggPageData);\n      } else {\n        let frames = [oggPage];\n\n        switch (this._syncState) {\n          case NOT_SYNCED:\n            this._frameQueue.initSync();\n            this._syncState = SYNCING;\n          case SYNCING:\n            [frames, this._syncSuccessful] = this._frameQueue.sync(frames);\n\n            if (frames.length) {\n              this._syncState = SYNCED;\n\n              if (this._syncSuccessful) {\n                // don't append the initial ogg pages when recovering from sync\n                this._resetOggPageBuffer();\n              } else {\n                // there is a gap in the old and new frames so reset everything and start over decoding\n                await this.reset();\n              }\n            } else {\n              break;\n            }\n          case SYNCED:\n            if (this._oggPageBufferLength) {\n              // add the first audio page to the buffer\n              this._addOggPageBuffer(oggPageData);\n              // get the initialization pages along with the first audio page to be sent to the decoder\n              oggPageData = this._getOggPageBuffer();\n\n              this._resetOggPageBuffer();\n            }\n\n            await this._opusDecoder.ready;\n            this._opusDecoder.decode(oggPageData);\n          default:\n            this._frameQueue.addAll(frames); // always add frames\n        }\n      }\n    }\n  }\n\n  _onDecode({ channelData, samplesDecoded }) {\n    if (\n      this._icecast.state !== state.STOPPING &&\n      this._icecast.state !== state.STOPPED\n    ) {\n      if (!this._startTime) this._startTime = Date.now();\n\n      if (this.metadataTimestamp < this._audioContext.currentTime) {\n        // audio context time starts incrementing immediately when it's created\n        // offset needs to be accounted for to prevent overlapping sources\n        this._currentSampleOffset += Math.floor(\n          this._audioContext.currentTime * this._sampleRate\n        );\n      }\n\n      const audioBuffer = this._audioContext.createBuffer(\n        channelData.length,\n        samplesDecoded,\n        this._sampleRate\n      );\n\n      channelData.forEach((channel, idx) =>\n        audioBuffer.getChannelData(idx).set(channel)\n      );\n\n      const source = this._audioContext.createBufferSource();\n      source.buffer = audioBuffer;\n      source.connect(this._mediaStream);\n      source.start(this.metadataTimestamp);\n\n      if (!this._firedPlay) {\n        this._icecast[fireEvent](event.PLAY);\n        this._firedPlay = true;\n      }\n\n      this._currentSample += samplesDecoded;\n    }\n  }\n\n  _addOggPageBuffer(oggPageData) {\n    this._oggPageBuffer.push(oggPageData);\n    this._oggPageBufferLength += oggPageData.length;\n  }\n\n  _getOggPageBuffer() {\n    const data = new Uint8Array(this._oggPageBufferLength);\n\n    let offset = 0;\n    for (const buf of this._oggPageBuffer) {\n      data.set(buf, offset);\n      offset += buf.length;\n    }\n\n    return data;\n  }\n\n  _resetOggPageBuffer() {\n    // store any non audio ogg pages\n    this._oggPageBuffer = [];\n    this._oggPageBufferLength = 0;\n  }\n}\n","import { IcecastReadableStream } from \"icecast-metadata-js\";\nimport CodecParser from \"codec-parser\";\nimport {\n  p,\n  event,\n  audioElement,\n  endpoint,\n  metadataTypes,\n  icyMetaInt,\n  icyDetectionTimeout,\n  fireEvent,\n  hasIcy,\n  abortController,\n} from \"./global.js\";\n\nimport Player from \"./players/Player.js\";\nimport HTML5Player from \"./players/HTML5Player.js\";\nimport MediaSourcePlayer from \"./players/MediaSourcePlayer.js\";\nimport WebAudioPlayer from \"./players/WebAudioPlayer.js\";\n\nexport default class PlayerFactory {\n  constructor(icecast, preferredPlaybackMethod) {\n    const instanceVariables = p.get(icecast);\n\n    this._icecast = icecast;\n    this._audioElement = instanceVariables[audioElement];\n    this._endpoint = instanceVariables[endpoint];\n    this._metadataTypes = instanceVariables[metadataTypes];\n    this._icyMetaInt = instanceVariables[icyMetaInt];\n    this._icyDetectionTimeout = instanceVariables[icyDetectionTimeout];\n\n    this._hasIcy = instanceVariables[hasIcy];\n\n    this._preferredPlaybackMethod = preferredPlaybackMethod || \"mediasource\";\n    this._playbackMethod = \"\";\n    this._player = new Player(this._icecast);\n    this._unprocessedFrames = [];\n    this._codecParser = undefined;\n    this._inputMimeType = \"\";\n    this._codec = \"\";\n  }\n\n  get player() {\n    return this._player;\n  }\n\n  get playbackMethod() {\n    return this._playbackMethod;\n  }\n\n  get icyMetaInt() {\n    return (\n      this._icecastReadableStream && this._icecastReadableStream.icyMetaInt\n    );\n  }\n\n  async playStream() {\n    return this.fetchStream().then(async (res) => {\n      this._icecast[fireEvent](event.STREAM_START);\n\n      return this.readIcecastResponse(res).finally(() => {\n        this._icecast[fireEvent](event.STREAM_END);\n      });\n    });\n  }\n\n  async fetchStream() {\n    const res = await fetch(this._endpoint, {\n      method: \"GET\",\n      headers: this._hasIcy ? { \"Icy-MetaData\": 1 } : {},\n      signal: p.get(this._icecast)[abortController].signal,\n    });\n\n    if (!res.ok) {\n      const error = new Error(`${res.status} received from ${res.url}`);\n      error.name = \"HTTP Response Error\";\n      throw error;\n    }\n\n    return res;\n  }\n\n  async readIcecastResponse(res) {\n    const inputMimeType = res.headers.get(\"content-type\");\n\n    const codecPromise = new Promise((onCodec) => {\n      this._codecParser = new CodecParser(inputMimeType, {\n        onCodecUpdate: (...args) =>\n          this._icecast[fireEvent](event.CODEC_UPDATE, ...args),\n        onCodec,\n      });\n    });\n\n    this._icecastReadableStream = new IcecastReadableStream(res, {\n      onMetadata: async (metadata) => {\n        this._player.onMetadata(metadata);\n      },\n      onStream: async ({ stream }) => {\n        this._icecast[fireEvent](event.STREAM, stream);\n\n        const frames = [...this._codecParser.iterator(stream)];\n\n        if (this._player.isAudioPlayer) {\n          await this._player.onStream([...this._unprocessedFrames, ...frames]);\n\n          this._unprocessedFrames = [];\n        } else {\n          this._unprocessedFrames.push(...frames);\n        }\n      },\n      onError: (...args) => this._icecast[fireEvent](event.WARN, ...args),\n      metadataTypes: this._metadataTypes,\n      icyMetaInt: this._icyMetaInt,\n      icyDetectionTimeout: this._icyDetectionTimeout,\n    });\n\n    const icecastPromise = this._icecastReadableStream.startReading();\n\n    if (!this._player.isAudioPlayer) {\n      this._buildPlayer(inputMimeType, await codecPromise);\n    }\n\n    await icecastPromise;\n  }\n\n  _buildPlayer(inputMimeType, codec) {\n    // in order of preference\n    const { [this._preferredPlaybackMethod]: firstMethod, ...rest } = {\n      mediasource: MediaSourcePlayer,\n      webaudio: WebAudioPlayer,\n      html5: HTML5Player,\n    };\n\n    for (const player of Object.values({ firstMethod, ...rest })) {\n      const support = player.canPlayType(`${inputMimeType};codecs=\"${codec}\"`);\n\n      if (support === \"probably\" || support === \"maybe\") {\n        this._playbackMethod = player.name;\n        this._player = new player(this._icecast, inputMimeType, codec);\n        break;\n      }\n    }\n\n    if (!this._player) {\n      throw new Error(\n        `Your browser does not support this audio codec ${inputMimeType}${\n          codec && `;codecs=\"${codec}\"`\n        }`\n      );\n    }\n  }\n}\n","import React, {\n  useState,\n  useCallback,\n  useEffect,\n  useLayoutEffect,\n  useRef,\n} from \"react\";\nimport AudioMotionAnalyzer from \"audiomotion-analyzer\";\nimport Player from \"./Player/Player\";\nimport StationSelector from \"./StationSelector/StationSelector\";\nimport stations from \"./stations.json\";\nimport styles from \"./App.module.css\";\nimport About from \"./About/About\";\n\nimport IcecastMetadataPlayer from \"icecast-metadata-player\";\n\nconst SELECT_STATION = \"Select a station\";\nconst SELECT_OR_PLAY = \"Select a station or press play\";\nconst LOADING = \"Loading...\";\nconst RECONNECTING = \"Lost Connection. Reconnecting...\";\nconst CONNECTED = \"Waiting for metadata...\";\n\nconst App = () => {\n  const [station, setStation] = useState();\n  const [playing, setPlaying] = useState(false);\n  const [audioElement] = useState(new Audio());\n\n  const [metadata, setMetadata] = useState(SELECT_STATION);\n  const [icecast, setIcecast] = useState();\n\n  const analyzer = useRef();\n  const [audioMotion, setAudioMotion] = useState();\n\n  const changeStation = useCallback(\n    async (station) => {\n      if (icecast) {\n        await icecast.stop();\n        icecast.detachAudioElement();\n      }\n\n      const player = new IcecastMetadataPlayer(station.endpoint, {\n        onMetadata: (meta) => {\n          console.log(meta);\n          setMetadata(meta);\n        },\n        onPlay: () => {\n          setPlaying(true);\n        },\n        onStop: () => {\n          setPlaying(false);\n          setMetadata(SELECT_OR_PLAY);\n        },\n        onLoad: () => {\n          setPlaying(true);\n          setMetadata(LOADING);\n        },\n        onError: (error) => {\n          setMetadata(error?.message || error);\n        },\n        onRetry: () => {\n          setMetadata(RECONNECTING);\n        },\n        onStreamStart: () => {\n          setMetadata(CONNECTED);\n        },\n        icyDetectionTimeout: 5000,\n        enableLogging: true,\n        metadataTypes: station.metadataTypes,\n        audioElement,\n      });\n\n      player.play();\n\n      setIcecast(player);\n      setStation(station);\n    },\n    [icecast, audioElement]\n  );\n\n  const toggle = useCallback(() => {\n    playing ? icecast.stop() : icecast.play();\n  }, [icecast, playing]);\n\n  useEffect(() => {\n    setAudioMotion(\n      new AudioMotionAnalyzer(analyzer.current, {\n        source: audioElement,\n        showScaleX: false,\n        fftSize: 32768,\n        mode: 1,\n        gradient: \"prism\",\n        showBgColor: false,\n        barSpace: 0,\n        lumiBars: true,\n      })\n    );\n  }, [audioElement]);\n\n  // adjust canvas size for audio spectrum\n  useLayoutEffect(() => {\n    const resizeObserver = new ResizeObserver(() => {\n      audioMotion &&\n        audioMotion.setCanvasSize(window.innerWidth, window.innerHeight + 100);\n    });\n    resizeObserver.observe(analyzer.current);\n    return () => resizeObserver.disconnect();\n  }, [audioMotion]);\n\n  return (\n    <>\n      <div className={styles.spectrum} ref={analyzer}></div>\n      <header className={styles.header}>\n        <About />\n      </header>\n      <main>\n        <StationSelector stations={stations} changeStation={changeStation} />\n      </main>\n      <footer className={styles.footer}>\n        <Player\n          station={station}\n          toggle={toggle}\n          playing={playing}\n          metadata={metadata}\n        ></Player>\n      </footer>\n    </>\n  );\n};\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === \"localhost\" ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === \"[::1]\" ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === \"production\" && \"serviceWorker\" in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener(\"load\", () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            \"This web app is being served cache-first by a service \" +\n              \"worker. To learn more, visit https://bit.ly/CRA-PWA\"\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then((registration) => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === \"installed\") {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                \"New content is available and will be used when all \" +\n                  \"tabs for this page are closed. See https://bit.ly/CRA-PWA.\"\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log(\"Content is cached for offline use.\");\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch((error) => {\n      console.error(\"Error during service worker registration:\", error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { \"Service-Worker\": \"script\" },\n  })\n    .then((response) => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get(\"content-type\");\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf(\"javascript\") === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then((registration) => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        \"No internet connection found. App is running in offline mode.\"\n      );\n    });\n}\n\nexport function unregister() {\n  if (\"serviceWorker\" in navigator) {\n    navigator.serviceWorker.ready\n      .then((registration) => {\n        registration.unregister();\n      })\n      .catch((error) => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport \"./index.css\";\nimport App from \"./App\";\nimport * as serviceWorker from \"./serviceWorker\";\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById(\"root\")\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}
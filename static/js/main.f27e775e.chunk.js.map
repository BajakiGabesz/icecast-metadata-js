{"version":3,"sources":["Player/Player.module.css","StationSelector/StationSelector.module.css","About/About.module.css","App.module.css","icecast/metadata-js/MetadataBuffer.js","icecast/metadata-js/IcecastMetadataReader.js","icecast/metadata-js/IcecastMetadataQueue.js","icecast/BufferArray.js","icecast/MetadataPlayer.js","Player/play.svg","Player/pause.svg","Player/Player.jsx","StationSelector/StationSelector.jsx","About/About.jsx","App.js","serviceWorker.js","index.js"],"names":["module","exports","MetadataBuffer","expectedLength","this","_buffer","Uint8Array","_length","data","set","length","Stats","_metadataBytesRead","_streamBytesRead","_totalBytesRead","_currentStreamPosition","metadataBytesRead","streamBytesRead","totalBytesRead","currentStreamPosition","bytes","noOp","IcecastMetadataReader","icyMetaInt","onStream","onMetadata","_icyMetaInt","_remainingData","_currentPosition","_stats","_onStream","_onMetadata","_decoder","TextDecoder","_generator","next","metadataBytes","parseMetadataString","decode","chunk","i","value","_getStream","_getMetadataLength","_getMetadata","_getNextValue","stream","addStreamBytes","addCurrentStreamPosition","streamPayload","stats","metadata","_storeMetadata","addMetadataBytes","metadataPayload","parseMetadata","currentMetadata","metadataBuffer","push","pop","subarray","addBytes","metadataString","matchAll","match","IcecastMetadataQueue","icyBr","onMetadataUpdate","_icyBr","_onMetadataUpdate","_metadataQueue","bufferOffset","time","getTimeByBytes","_enqueueMetadata","bytesRead","forEach","clearTimeout","_timeoutId","setTimeout","_dequeueMetadata","shift","map","BufferArray","init","_bufferFunction","_buffers","_totalBytes","_currentLength","_currentIndex","_trimTail","_newBuffer","offset","returnBuffer","buf","MetadataPlayer","_icecastMetadataQueue","meta","_audioElement","Audio","_icecast","_streamBuffer","_playing","addMetadata","_sourceBuffer","timestampOffset","currentTime","mimeType","_mediaSource","MediaSource","src","URL","createObjectURL","Promise","resolve","addEventListener","addSourceBuffer","once","_playPromise","then","removeAttribute","load","catch","addBuffer","append","currentPosition","_appendSourceBuffer","readAll","appendBuffer","endpoint","fetch","method","mode","headResponse","headers","signal","_controller","metaInt","stop","AbortController","streamPromise","fetchStream","race","fetchMimeType","res","a","get","isTypeSupported","_createMediaSource","Error","play","parseInt","reader","body","getReader","readerIterator","Symbol","asyncIterator","read","_readIcecastResponse","e","name","message","_destroyMediaSource","abort","purgeMetadataQueue","_extends","Object","assign","target","arguments","source","key","prototype","hasOwnProperty","call","apply","_objectWithoutProperties","excluded","sourceKeys","keys","indexOf","_objectWithoutPropertiesLoose","getOwnPropertySymbols","sourceSymbolKeys","propertyIsEnumerable","createElement","fill","d","_ref","svgRef","title","props","viewBox","ref","ForwardRef","forwardRef","station","useState","console","log","metadataPlayer","useCallback","useEffect","playing","useMetadataPlayer","isPlaying","toggle","className","styles","player","disabled","Boolean","button","onClick","StreamTitle","link","visitStation","href","rel","Station","id","changeStation","type","stationRadio","onChange","stationLabel","htmlFor","stationName","stationDescription","description","stations","idx","about","subLink","disclaimer","App","setStation","header","About","headerGradient","StationSelector","footer","Player","window","location","hostname","ReactDOM","render","StrictMode","document","getElementById","navigator","serviceWorker","ready","registration","unregister","error"],"mappings":"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","file":"static/js/main.f27e775e.chunk.js","sourcesContent":["// extracted by mini-css-extract-plugin\nmodule.exports = {\"player\":\"Player_player__1vYfQ\",\"metadata\":\"Player_metadata__3j7ae\",\"button\":\"Player_button__297uW\",\"link\":\"Player_link__2k87w\",\"visitStation\":\"Player_visitStation__2xKeH\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"station\":\"StationSelector_station__3a44c\",\"stationRadio\":\"StationSelector_stationRadio__1FTGQ\",\"stationLabel\":\"StationSelector_stationLabel__1DbUR\",\"stationName\":\"StationSelector_stationName__1hB_K\",\"stationDescription\":\"StationSelector_stationDescription__36TBn\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"about\":\"About_about__2v-0B\",\"link\":\"About_link__1z8T1\",\"subLink\":\"About_subLink__n5KCY\",\"description\":\"About_description__3WN3o\",\"disclaimer\":\"About_disclaimer__2gOk6\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"header\":\"App_header__3ZZ1n\",\"footer\":\"App_footer__29Fsv\"};","/* Copyright 2020 Ethan Halsall\n\n    This program is free software: you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with this program.  If not, see <https://www.gnu.org/licenses/>\n*/\n\n// Use fast buffer allocation if this is a NodeJS runtime or Uint8Array if a browser runtime\nconst bufferFunction = (length) => new Uint8Array(length);\n\n/**\n * @description Stores a collection of buffers as an array.\n */\nexport default class MetadataBuffer {\n  constructor(expectedLength) {\n    this._buffer = bufferFunction(expectedLength);\n    this._length = 0;\n  }\n\n  get length() {\n    return this._length;\n  }\n\n  /**\n   * @type {Uint8Array} Returns all stored data\n   */\n  pop() {\n    return this._buffer;\n  }\n\n  push(data) {\n    this._buffer.set(data, this._length);\n    this._length += data.length;\n  }\n}\n","/* Copyright 2020 Ethan Halsall\n\n    This program is free software: you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with this program.  If not, see <https://www.gnu.org/licenses/>\n*/\n\nimport MetadataBuffer from \"./MetadataBuffer\";\n\nclass Stats {\n  constructor() {\n    this._metadataBytesRead = 0;\n    this._streamBytesRead = 0;\n    this._totalBytesRead = 0;\n    this._currentStreamPosition = 0;\n  }\n\n  get stats() {\n    return {\n      metadataBytesRead: this._metadataBytesRead,\n      streamBytesRead: this._streamBytesRead,\n      totalBytesRead: this._totalBytesRead,\n      currentStreamPosition: this._currentStreamPosition,\n    };\n  }\n\n  set addMetadataBytes(bytes) {\n    this._metadataBytesRead += bytes;\n  }\n\n  set addStreamBytes(bytes) {\n    this._streamBytesRead += bytes;\n  }\n\n  set addBytes(bytes) {\n    this._totalBytesRead += bytes;\n  }\n\n  set currentStreamPosition(bytes) {\n    this._currentStreamPosition = bytes;\n  }\n\n  set addCurrentStreamPosition(bytes) {\n    this._currentStreamPosition += bytes;\n  }\n}\n\nconst noOp = () => {};\n\n/**\n * @description Splits Icecast raw response into stream bytes and metadata key / value pairs.\n * @param {number} icyMetaInt Interval in bytes of metadata updates returned by the Icecast server\n *\n * @callback onMetadata\n * @param {object} value Object containing Metadata and Statistics\n * @param {object} metadata Object containing the metadata received.\n * @param {string} [metadata.StreamTitle] Title of the metadata update.\n * @param {string} [metadata.StreamUrl] Url (usually album art) of the metadata update.\n * @param {object} stats Object containing statistics on how many bytes were read and the current read position.\n *\n * @callback onStream\n * @param {object} value Object containing Stream data and Statistics\n * @param {Uint8Array} stream Object containing the stream buffer.\n * @param {object} stats Object containing statistics on how many bytes were read and the current read position.\n */\nexport default class IcecastMetadataReader {\n  constructor({ icyMetaInt, onStream = noOp, onMetadata = noOp }) {\n    this._icyMetaInt = icyMetaInt;\n    this._remainingData = 0;\n    this._currentPosition = 0;\n    this._buffer = null;\n    this._stats = new Stats();\n    this._onStream = onStream;\n    this._onMetadata = onMetadata;\n    this._decoder = new TextDecoder(\"utf-8\");\n\n    this._generator = this._generator();\n    this._generator.next();\n  }\n\n  /**\n   * @description Parses an Icecast metadata string into key value pairs.\n   * @param {string} metadataString Icecast formatted metadata string. (i.e. \"StreamTitle='A Title';\")\n   * @returns {object} Parsed metadata key value pairs. (i.e. {StreamTitle: \"A Title\"})\n   */\n  static parseMetadataString(metadataString) {\n    /**\n     * Metadata is a string of key='value' pairs delimited by a semicolon.\n     * The string is a fixed length and any unused bytes at the end are 0x00.\n     * i.e. \"StreamTitle='The Stream Title';StreamUrl='https://example.com';\\0\\0\\0\\0\\0\\0\"\n     */\n\n    const metadata = {};\n    // [{key: \"StreamTitle\", val: \"The Stream Title\"}, {key: \"StreamUrl\", val: \"https://example.com\"}]\n    for (let match of metadataString.matchAll(\n      /(?<key>[^\\0]+?)='(?<val>[^\\0]*?)(;$|';|'$|$)/g\n    )) {\n      metadata[match[\"groups\"][\"key\"]] = match[\"groups\"][\"val\"];\n    }\n    // {StreamTitle: \"The Stream Title\", StreamUrl: \"https://example.com\"}\n    return metadata;\n  }\n\n  /**\n   * @description Parses Icecast metadata bytes into key value pairs.\n   * @param {Uint8Array} metadataBytes Bytes containing Icecast metadata.\n   * @returns {object} Parsed metadata key value pairs. (i.e. {StreamTitle: \"A Title\"})\n   */\n  parseMetadata(metadataBytes) {\n    return IcecastMetadataReader.parseMetadataString(\n      this._decoder.decode(metadataBytes)\n    );\n  }\n\n  /**\n   * @description Reads through an icecast response and emits stream and metadata events.\n   * @param {Uint8Array} chunk Bytes to split into stream and metadata\n   */\n  readAll(chunk) {\n    for (\n      let i = this._generator.next(chunk);\n      i.value;\n      i = this._generator.next()\n    ) {}\n  }\n\n  /**\n   * @description Generator next function.\n   * @param {Uint8Array} data Next chunk of data to read\n   * @returns {object} Object containing stream or metadata. Returns undefined when out of data to read.\n   */\n  next(data) {\n    return this._generator.next(data);\n  }\n\n  *_generator() {\n    do {\n      yield* this._getStream();\n      yield* this._getMetadataLength();\n      this._remainingData && (yield* this._getMetadata());\n    } while (true);\n  }\n\n  *_getStream() {\n    this._remainingData = this._icyMetaInt;\n\n    do {\n      const stream = yield* this._getNextValue();\n      this._stats.addStreamBytes = stream.length;\n      this._stats.addCurrentStreamPosition = stream.length;\n\n      const streamPayload = { stream, stats: this._stats.stats };\n      /**\n       * Stream callback.\n       *\n       * @callback onStream\n       * @type {object}\n       * @property {Uint8Array} stream Stream bytes.\n       * @property {object} stats Statistics on bytes read.\n       */\n      this._onStream(streamPayload);\n\n      yield streamPayload;\n    } while (this._remainingData);\n  }\n\n  *_getMetadataLength() {\n    this._remainingData = 1;\n\n    do {\n      this._remainingData = (yield* this._getNextValue())[0] * 16;\n    } while (this._remainingData === 1);\n  }\n\n  *_getMetadata() {\n    let metadata = yield* this._getNextValue();\n    if (this._remainingData) metadata = yield* this._storeMetadata(metadata);\n\n    this._stats.addMetadataBytes = metadata.length;\n\n    const metadataPayload = {\n      metadata: this.parseMetadata(metadata),\n      stats: this._stats.stats,\n    };\n    /**\n     * Metadata callback.\n     *\n     * @callback onMetadata\n     * @type {object}\n     * @property {object} metadata Metadata key value pairs..\n     * @param {property} [metadata.StreamTitle] Title of the metadata update.\n     * @param {property} [metadata.StreamUrl] Url (usually album art) of the metadata update.\n     * @property {object} stats Statistics on bytes read.\n     */\n    this._onMetadata(metadataPayload);\n\n    yield metadataPayload;\n  }\n\n  *_storeMetadata(currentMetadata) {\n    // Store any partial metadata updates until a full metadata chunk can be parsed.\n    const metadataBuffer = new MetadataBuffer(\n      this._remainingData + currentMetadata.length\n    );\n    metadataBuffer.push(currentMetadata);\n\n    do {\n      metadataBuffer.push(yield* this._getNextValue());\n    } while (this._remainingData);\n\n    return metadataBuffer.pop();\n  }\n\n  *_getNextValue() {\n    while (!this._buffer || this._currentPosition === this._buffer.length) {\n      this._buffer = yield; // if out of data, accept new data in the .next() call\n      this._currentPosition = 0;\n      this._stats.currentStreamPosition = 0;\n    }\n    const value = this._buffer.subarray(\n      this._currentPosition,\n      this._remainingData + this._currentPosition\n    );\n\n    this._remainingData -= value.length;\n    this._currentPosition += value.length;\n    this._stats.addBytes = value.length;\n\n    return value;\n  }\n}\n","/* Copyright 2020 Ethan Halsall\n\n    This program is free software: you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with this program.  If not, see <https://www.gnu.org/licenses/>\n*/\n\nexport default class IcecastMetadataQueue {\n  /**\n   * @description Schedules updates up to the millisecond for Icecast Metadata from the response body of an Icecast stream mountpoint\n   * @description The accuracy of metadata updates is a direct relationship of the icyMetaInt\n   * @param {Object} IcecastMetadataQueue constructor parameter\n   * @param {number} [IcecastMetadataQueue.icyBr] Bitrate of audio stream used to increase accuracy when to updating metadata\n   * @param {onMetadataUpdate} [IcecastMetadataQueue.onMetadataUpdate] Callback executed when metadata is scheduled to update\n   *\n   * @callback onMetadataUpdate\n   * @param {Object} metadata Object containing all metadata received.\n   * @param {string} [metadata.StreamTitle] Title of the metadata update.\n   * @param {string} [metadata.StreamUrl] Url (usually album art) of the metadata update.\n   * @param {number} time Time in seconds the metadata should be displayed / recorded\n   *\n   */\n\n  constructor({ icyBr, onMetadataUpdate = () => {} }) {\n    this._icyBr = icyBr;\n    this._onMetadataUpdate = onMetadataUpdate;\n    this._metadataQueue = [];\n  }\n\n  /**\n   * @description Returns the metadata queued for updates\n   * @type {{metadata: string, time: number}[]} Queued metadata\n   */\n  get metadataQueue() {\n    return this._metadataQueue.map(({ metadata, time }) => ({\n      metadata,\n      time,\n    }));\n  }\n\n  /**\n   *\n   * @param {object} metadata Metadata object returned from IcecastMetadataReader\n   * @param {number} bufferOffset Total buffered audio in seconds\n   */\n  addMetadata({ metadata, stats }, bufferOffset) {\n    /**\n     * Metadata time is derived from the total number of stream bytes read\n     * since the latest buffer input. The buffer offset should be the total\n     * seconds of audio in the player buffer when the metadata was read.\n     */\n    const time =\n      bufferOffset + this.getTimeByBytes(stats.currentStreamPosition);\n\n    this._enqueueMetadata(metadata, time);\n  }\n\n  /**\n   * @description Calculates audio stream length based on bitrate\n   * @param {number} bytesRead Number of bytes\n   * @type {number} Seconds\n   */\n  getTimeByBytes(bytesRead) {\n    return this._icyBr ? bytesRead / (this._icyBr * 125) : 0;\n  }\n\n  /**\n   * @description Clears all metadata updates and empties the queue\n   */\n  purgeMetadataQueue() {\n    this._metadataQueue.forEach((i) => clearTimeout(i._timeoutId));\n    this._metadataQueue = [];\n  }\n\n  _enqueueMetadata(metadata, time) {\n    this._metadataQueue.push({\n      _timeoutId: setTimeout(() => {\n        this._dequeueMetadata();\n      }, time * 1000), // trigger timeout relative to play position\n      metadata,\n    });\n  }\n\n  _dequeueMetadata() {\n    const { metadata } = this._metadataQueue.shift();\n    this._onMetadataUpdate(metadata);\n  }\n}","/**\n * @description Stores a collection of buffers as an array.\n */\nexport default class BufferArray {\n  constructor() {\n    this.init();\n    this._bufferFunction = (length) => new Uint8Array(length);\n  }\n\n  /**\n   * @description Resets all internal state\n   */\n  init() {\n    this._buffers = [];\n    this._totalBytes = 0;\n    this._currentLength = 0;\n    this._currentIndex = -1;\n  }\n\n  /**\n   * @type {number} Length of all stored data in bytes\n   */\n  get length() {\n    return this._totalBytes;\n  }\n\n  /**\n   * @type {Uint8Array} Returns all stored data\n   */\n  get readAll() {\n    let offset = 0;\n    this._buffers.length && this._trimTail();\n    const returnBuffer = this._newBuffer(this._totalBytes);\n\n    this._buffers.forEach((buf) => {\n      returnBuffer.set(buf, offset);\n      offset += buf.length;\n    });\n\n    this.init();\n\n    return returnBuffer;\n  }\n\n  /**\n   * @description Adds a new buffer using Buffer.allocUnsafe\n   * @param {number} length Bytes to allocate for the buffer\n   */\n  addBuffer(length) {\n    this._buffers.length && this._trimTail();\n    this._buffers.push(this._newBuffer(length));\n    this._currentLength = 0;\n    this._currentIndex++;\n  }\n\n  /**\n   * @description Appends data to the currently allocated buffer\n   * @param {Uint8Array} data Data to append\n   */\n  append(data) {\n    this._buffers[this._currentIndex].set(data, this._currentLength);\n    this._currentLength += data.length;\n    this._totalBytes += data.length;\n  }\n\n  _trimTail() {\n    this._buffers[this._currentIndex] = this._buffers[\n      this._currentIndex\n    ].subarray(0, this._currentLength);\n  }\n\n  _newBuffer(length) {\n    return this._bufferFunction(length);\n  }\n}\n","import IcecastMetadataReader from \"./metadata-js/IcecastMetadataReader\";\nimport IcecastMetadataQueue from \"./metadata-js/IcecastMetadataQueue\";\nimport BufferArray from \"./BufferArray\";\n\nexport default class MetadataPlayer {\n  constructor({ onMetadataUpdate }) {\n    this._icecastMetadataQueue = new IcecastMetadataQueue({\n      onMetadataUpdate: (meta) => onMetadataUpdate(meta),\n    });\n    this._audioElement = new Audio();\n    this._onMetadataUpdate = onMetadataUpdate;\n\n    this._icecast = null;\n    this._streamBuffer = new BufferArray();\n\n    this._playing = false;\n  }\n\n  get playing() {\n    return this._playing;\n  }\n\n  _onMetadata(value) {\n    this._icecastMetadataQueue.addMetadata(\n      value,\n      this._sourceBuffer.timestampOffset - this._audioElement.currentTime\n    );\n  }\n\n  async _createMediaSource(mimeType) {\n    this._mediaSource = new MediaSource();\n    this._audioElement.src = URL.createObjectURL(this._mediaSource);\n\n    return new Promise((resolve) => {\n      this._mediaSource.addEventListener(\n        \"sourceopen\",\n        () => {\n          this._sourceBuffer = this._mediaSource.addSourceBuffer(mimeType);\n          resolve();\n        },\n        { once: true }\n      );\n    });\n  }\n\n  _destroyMediaSource() {\n    this._mediaSource = null;\n    this._playPromise &&\n      this._playPromise\n        .then(() => this._audioElement.removeAttribute(\"src\"))\n        .then(() => this._audioElement.load())\n        .catch(() => {});\n  }\n\n  async _readIcecastResponse(value) {\n    this._streamBuffer.addBuffer(value.length);\n\n    for (let i = this._icecast.next(value); i.value; i = this._icecast.next()) {\n      if (i.value.stream) {\n        this._streamBuffer.append(i.value.stream);\n      } else {\n        const currentPosition = value.length - this._streamBuffer.length;\n        await this._appendSourceBuffer(this._streamBuffer.readAll);\n\n        this._streamBuffer.addBuffer(currentPosition);\n        this._onMetadata(i.value);\n      }\n    }\n\n    return this._appendSourceBuffer(this._streamBuffer.readAll);\n  }\n\n  async _appendSourceBuffer(chunk) {\n    this._sourceBuffer.appendBuffer(chunk);\n\n    return new Promise((resolve) => {\n      this._sourceBuffer.addEventListener(\"updateend\", resolve, { once: true });\n    });\n  }\n\n  async fetchMimeType(endpoint) {\n    const headResponse = await fetch(endpoint, {\n      method: \"HEAD\",\n      mode: \"cors\",\n    }).catch(() => {});\n\n    return headResponse ? headResponse : new Promise(() => {});\n  }\n\n  async fetchStream(endpoint) {\n    return fetch(endpoint, {\n      method: \"GET\",\n      headers: {\n        \"Icy-MetaData\": \"1\",\n      },\n      mode: \"cors\",\n      signal: this._controller.signal,\n    });\n  }\n\n  play(endpoint, metaInt) {\n    if (this._playing) {\n      this.stop();\n    }\n\n    this._playing = true;\n    this._controller = new AbortController();\n\n    const streamPromise = this.fetchStream(endpoint);\n\n    Promise.race([this.fetchMimeType(endpoint), streamPromise])\n      .then(async (res) => {\n        const mimeType = res.headers.get(\"content-type\");\n\n        if (MediaSource.isTypeSupported(mimeType)) {\n          await this._createMediaSource(mimeType);\n          return streamPromise;\n        } else {\n          throw new Error(\n            `Your browser does not support MediaSource ${mimeType}. Try using Google Chrome.`\n          );\n        }\n      })\n      .then(async (res) => {\n        this._playPromise = this._audioElement.play();\n\n        this._icecast = new IcecastMetadataReader({\n          icyMetaInt: parseInt(res.headers.get(\"Icy-MetaInt\")) || metaInt,\n        });\n\n        const reader = res.body.getReader();\n        const readerIterator = {\n          [Symbol.asyncIterator]: () => ({\n            next: () => reader.read(),\n          }),\n        };\n\n        for await (const chunk of readerIterator) {\n          await this._readIcecastResponse(chunk);\n        }\n      })\n      .catch((e) => {\n        if (e.name !== \"AbortError\") {\n          this._onMetadataUpdate(`Error Connecting: ${e.message}`);\n        }\n        this._destroyMediaSource();\n      });\n  }\n\n  stop() {\n    this._playing = false;\n    this._controller.abort();\n    this._icecastMetadataQueue.purgeMetadataQueue();\n  }\n}\n","function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\nimport React from \"react\";\n\nvar _ref2 = /*#__PURE__*/React.createElement(\"path\", {\n  fill: \"#808080\",\n  d: \"M424.4 214.7L72.4 6.6C43.8-10.3 0 6.1 0 47.9V464c0 37.5 40.7 60.1 72.4 41.3l352-208c31.4-18.5 31.5-64.1 0-82.6z\"\n});\n\nvar SvgPlay = function SvgPlay(_ref) {\n  var svgRef = _ref.svgRef,\n      title = _ref.title,\n      props = _objectWithoutProperties(_ref, [\"svgRef\", \"title\"]);\n\n  return /*#__PURE__*/React.createElement(\"svg\", _extends({\n    viewBox: \"0 0 448 512\",\n    ref: svgRef\n  }, props), title ? /*#__PURE__*/React.createElement(\"title\", null, title) : null, _ref2);\n};\n\nvar ForwardRef = /*#__PURE__*/React.forwardRef(function (props, ref) {\n  return /*#__PURE__*/React.createElement(SvgPlay, _extends({\n    svgRef: ref\n  }, props));\n});\nexport default __webpack_public_path__ + \"static/media/play.0187bd2f.svg\";\nexport { ForwardRef as ReactComponent };","function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\nimport React from \"react\";\n\nvar _ref2 = /*#__PURE__*/React.createElement(\"path\", {\n  fill: \"#808080\",\n  d: \"M144 479H48c-26.5 0-48-21.5-48-48V79c0-26.5 21.5-48 48-48h96c26.5 0 48 21.5 48 48v352c0 26.5-21.5 48-48 48zm304-48V79c0-26.5-21.5-48-48-48h-96c-26.5 0-48 21.5-48 48v352c0 26.5 21.5 48 48 48h96c26.5 0 48-21.5 48-48z\"\n});\n\nvar SvgPause = function SvgPause(_ref) {\n  var svgRef = _ref.svgRef,\n      title = _ref.title,\n      props = _objectWithoutProperties(_ref, [\"svgRef\", \"title\"]);\n\n  return /*#__PURE__*/React.createElement(\"svg\", _extends({\n    viewBox: \"0 0 448 512\",\n    ref: svgRef\n  }, props), title ? /*#__PURE__*/React.createElement(\"title\", null, title) : null, _ref2);\n};\n\nvar ForwardRef = /*#__PURE__*/React.forwardRef(function (props, ref) {\n  return /*#__PURE__*/React.createElement(SvgPause, _extends({\n    svgRef: ref\n  }, props));\n});\nexport default __webpack_public_path__ + \"static/media/pause.b0b65543.svg\";\nexport { ForwardRef as ReactComponent };","import React, { useEffect, useState } from \"react\";\nimport MetadataPlayer from \"../icecast/MetadataPlayer\";\nimport { ReactComponent as Play } from \"./play.svg\";\nimport { ReactComponent as Pause } from \"./pause.svg\";\nimport styles from \"./Player.module.css\";\nimport { useCallback } from \"react\";\n\nconst SELECT_STATION = \"Select a station\";\nconst SELECT_OR_PLAY = \"Select a station or press play\";\nconst LOADING = \"Loading...\";\nconst VISIT_STATION = \"Visit this station at \";\n\nconst useMetadataPlayer = (station, onMetadataUpdate) => {\n  const [metadataPlayer] = useState(\n    new MetadataPlayer({\n      onMetadataUpdate: (meta) => {\n        console.log(meta);\n        onMetadataUpdate(meta);\n      },\n    })\n  );\n\n  const play = useCallback(() => {\n    onMetadataUpdate(LOADING);\n    metadataPlayer.play(station.endpoint, station.metaInt);\n  }, [onMetadataUpdate, metadataPlayer, station]);\n\n  const stop = useCallback(() => {\n    onMetadataUpdate(SELECT_OR_PLAY);\n    metadataPlayer.stop();\n  }, [onMetadataUpdate, metadataPlayer]);\n\n  useEffect(() => {\n    station && play();\n  }, [station, play]);\n\n  const toggle = () => (metadataPlayer.playing ? stop() : play());\n\n  return [metadataPlayer.playing, toggle];\n};\n\nexport default ({ station }) => {\n  const [metadata, setMetadata] = useState(SELECT_STATION);\n  const [isPlaying, toggle] = useMetadataPlayer(station, setMetadata);\n\n  return (\n    <div className={styles.player}>\n      <button\n        disabled={!Boolean(station)}\n        className={styles.button}\n        onClick={toggle}\n      >\n        {isPlaying ? <Pause /> : <Play />}\n      </button>\n      <div>\n        <p className={styles.metadata}>\n          {typeof metadata === \"object\" ? metadata.StreamTitle : metadata}\n        </p>\n        {station?.link && (\n          <div className={styles.visitStation}>\n            {VISIT_STATION}\n            <a\n              className={styles.link}\n              href={station.link}\n              target=\"_blank\"\n              rel=\"noopener noreferrer\"\n            >\n              {station.name}\n            </a>\n          </div>\n        )}\n      </div>\n    </div>\n  );\n};\n","import React from \"react\";\nimport styles from \"./StationSelector.module.css\";\n\nconst Station = ({ id, station, changeStation }) => (\n  <div className={styles.station}>\n    <input\n      type=\"radio\"\n      className={styles.stationRadio}\n      id={id}\n      name=\"stations\"\n      onChange={() => changeStation(station)}\n    ></input>\n    <label className={styles.stationLabel} htmlFor={id}>\n      <div className={styles.stationName}>{station.name}</div>\n      <div className={styles.stationDescription}>{station.description}</div>\n    </label>\n  </div>\n);\n\nexport default (props) =>\n  props.stations.map((station, idx) => (\n    <Station\n      key={idx}\n      station={station}\n      id={idx}\n      changeStation={props.changeStation}\n    />\n  ));\n","import React from \"react\";\nimport styles from \"./About.module.css\";\n\nexport default () => (\n  <div className={styles.about}>\n    <a\n      className={styles.link}\n      href=\"https://github.com/eshaz/icecast-metadata-js\"\n    >\n      <div>icecast-metadata-js</div>\n      <div className={styles.subLink}>\n        https://github.com/eshaz/icecast-metadata-js\n      </div>\n    </a>\n    <div className={styles.description}>\n      Javascript library that reads, parses, and queues realtime metadata from\n      an Icecast stream.\n    </div>\n    <div className={styles.disclaimer}>\n      Stations are presented here for demonstration purposes only.\n    </div>\n  </div>\n);\n","import React, { useState } from \"react\";\nimport Player from \"./Player/Player\";\nimport StationSelector from \"./StationSelector/StationSelector\";\nimport stations from \"./stations.json\";\nimport styles from \"./App.module.css\";\nimport About from \"./About/About\";\n\nfunction App() {\n  const [station, setStation] = useState();\n\n  return (\n    <div>\n      <header className={styles.header}>\n        <About />\n      </header>\n      <div className={styles.headerGradient}></div>\n      <StationSelector stations={stations} changeStation={setStation} />\n      <footer className={styles.footer}>\n        <Player station={station}></Player>\n      </footer>\n    </div>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === \"localhost\" ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === \"[::1]\" ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === \"production\" && \"serviceWorker\" in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener(\"load\", () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            \"This web app is being served cache-first by a service \" +\n              \"worker. To learn more, visit https://bit.ly/CRA-PWA\"\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then((registration) => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === \"installed\") {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                \"New content is available and will be used when all \" +\n                  \"tabs for this page are closed. See https://bit.ly/CRA-PWA.\"\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log(\"Content is cached for offline use.\");\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch((error) => {\n      console.error(\"Error during service worker registration:\", error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { \"Service-Worker\": \"script\" },\n  })\n    .then((response) => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get(\"content-type\");\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf(\"javascript\") === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then((registration) => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        \"No internet connection found. App is running in offline mode.\"\n      );\n    });\n}\n\nexport function unregister() {\n  if (\"serviceWorker\" in navigator) {\n    navigator.serviceWorker.ready\n      .then((registration) => {\n        registration.unregister();\n      })\n      .catch((error) => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport \"./index.css\";\nimport App from \"./App\";\nimport * as serviceWorker from \"./serviceWorker\";\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById(\"root\")\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}